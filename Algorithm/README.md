# Algorithm

### [손코딩 예상 문제 및 예제 답안](/손코딩/)

<details>
 <summary><strong>목차</strong></summary>
 <div>
 <br>

- [DFS와 BFS의 특징 및 차이점은?](#dfs와-bfs의-특징-및-차이점은)
- [피보나치 수를 구하는 함수를 다이나믹 프로그래밍으로 구현할 때, 탑 다운 방식과 바텀 업 방식이 무엇이고 또한, 이를 어떻게 구현할 수 있습니까?](#피보나치-수를-구하는-함수를-다이나믹-프로그래밍으로-구현할-때-탑-다운-방식과-바텀-업-방식이-무엇이고-또한-이를-어떻게-구현할-수-있습니까)
- [정렬 알고리즘의 종류와 특징을 설명해 주세요.](#정렬-알고리즘의-종류와-특징을-설명해-주세요)
    * [삽입 정렬의 최선의 경우, 퀵 정렬의 최악의 경우를 설명해 주세요.](#삽입-정렬의-최선의-경우-퀵-정렬의-최악의-경우를-설명해-주세요)
- [MST 알고리즘 중 Kruskal 알고리즘과 Prim 알고리즘을 설명하고 장단점을 설명해 주세요.](#mst-알고리즘-중-kruskal-알고리즘과-prim-알고리즘을-설명하고-장단점을-설명해-주세요)

</div>
</details>

## DFS와 BFS의 특징 및 차이점은?

DFS는 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법입니다. 재귀 함수를 이용하거나 스택을 이용하여 구현할 수 있습니다. 이와는 다르게 BFS는 인접한 노드를 먼저 탐색하는 방법입니다. 큐를 이용하여 구현할 수 있습니다. 깊은 단계의 노드를 탐색하는 과정이 필요한 지 최단 거리의 노드를 탐색하는 과정이 필요한 지 검토하여 각 특징에 알맞는 알고리즘을 선택할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#algorithm)**

## 피보나치 수를 구하는 함수를 다이나믹 프로그래밍으로 구현할 때, 탑 다운 방식과 바텀 업 방식이 무엇이고 또한, 이를 어떻게 구현할 수 있습니까?

예를 들어서, 탑다운 방식은 fibonacci(n)을 구하기 위해서 필요한 fibonacci(n-1), fibonacci(n-2)를 순차적으로 구하는 방식입니다. 큰 수를 구하기 위해 재귀적으로 작은 수들을 호출하면서 결과값을 구하는 방식입니다. 따라서, 재귀함수를 통해 구현할 수 있습니다. 바텀업 방식은 작은 수부터 차근차근 큰 수의 결과값을 구하여 그를 토대로 최종 결과값을 도출하는 방식이며, 반복문을 통해서 구현할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#algorithm)**

## 정렬 알고리즘의 종류와 특징을 설명해 주세요.

가장 간단한 알고리즘은 선택 정렬, 삽입 정렬, 버블 정렬이 있습니다. 각각 시간복잡도는 평균적으로 O(n^2)이며 삽입 정렬의 경우 최선의 경우 O(n)의 복잡도를 가집니다. 이 보다 좋은 알고리즘으론 퀵 정렬, 머지 정렬, 힙 정렬, 팀 정렬 등이 있습니다. 퀵 정렬을 제외한 알고리즘은 최악의 경우에도 O(n log n)의 복잡도를 가집니다. 이 중 팀 정렬은 머지 정렬의 특징에 삽입 정렬이 최선의 경우(배열이 정렬된 경우) O(n)의 복잡도를 가진다는 점을 접목시킨 알고리즘 입니다. 이 외에도 특이한 경우 사용할 수 있는 계수정렬이 있으며 O(n+k)의 복잡도를 보여줍니다. 이 때, k는 배열의 최댓값입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#algorithm)**

### 삽입 정렬의 최선의 경우, 퀵 정렬의 최악의 경우를 설명해 주세요.

모두 이미 정렬된 리스트를 정렬하는 경우 발생합니다. 먼저 삽입 정렬은 앞의 k-1개의 원소가 모두 정렬되어 있다는 가정 하에 k번째 원소를 적절한 위치에 삽입시키는 알고리즘 입니다. k번째 원소는 k-1번째 원소부터 시작하여 자신보다 작은 원소를 만날 때까지 비교를 시도하는데, 해당 리스트는 이미 정렬되어 있으므로 k-1번째 원소는 k번째 원소보다 값이 작습니다. 즉, 비교가 1회 이뤄집니다. 이것은 2번째부터 n번째 원소에 까지 해당하는 명제이므로 총 n-1회의 비교가 이뤄집니다. 따라서 이 경우 삽입 정렬은 O(n)의 복잡도를 가집니다.<br>
반면 퀵 정렬은 pivot을 맨 왼쪽이나 맨 오른쪽 원소를 택할 경우 위의 리스트는 항상 불균형하게 나눠지는 것을 확인할 수 있습니다. 결국 높이가 n인 트리가 됩니다. 이 때 n개의 원소에 대하여 n번의 비교가 발생하므로 O(n^2)의 복잡도를 가지게 됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#algorithm)**

## MST 알고리즘 중 Kruskal 알고리즘과 Prim 알고리즘을 설명하고 장단점을 설명해 주세요.

크루스칼 알고리즘은 최소 간선을 택해서 점차 MST를 만들어가는 알고리즘이며, 프림 알고리즘은 시작 노드에서 출발하여 조금씩 노드의 갯수를 MST를 유지하며 단계적으로 확장하는 알고리즘입니다.<br>
각각의 시간 복잡도가 O(e log e), O(v^2)이므로, 희소 그래프의 경우는 크루스칼 알고리즘이, 밀집 그래프의 경우는 프림 알고리즘이 유리하다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#algorithm)**