# 운영체제(OS)

<details>
 <summary><strong>목차</strong></summary>
 <div markdown = "1">

- [운영체제의 역활은 무엇입니까?](#운영체제의-역활은-무엇입니까)
    * [커널 모드와 사용자 모드는 무엇인가요?](#커널-모드와-사용자-모드는-무엇인가요)
    * [시스템 콜은 무엇인가요?](#시스템-콜은-무엇인가요)
- [프로세스와 스레드는 무엇인가요?](#프로세스와-스레드는-무엇인가요)
    * [PCB는 무엇인가요?](#pcb는-무엇인가요)
    * [프로세스의 상태 전이를 설명해 주세요.](#프로세스의-상태-전이를-설명해-주세요)
    * [IPC는 무엇인가요?](#ipc는-무엇인가요)
        + [IPC 종류와 특징에 대해 설명해 주세요.](#ipc-종류와-특징에-대해-설명해-주세요)
- [멀티 스레드와 멀티 프로세스가 무엇이고, 각각의 장단점은 무엇인가요?](#멀티-스레드와-멀티-프로세스가-무엇이고-각각의-장단점은-무엇인가요)
    * [멀티 스레딩 시 스레드마다 스택과 PC를 독립적으로 할당하는 이유는 무엇인가요?](#멀티-스레딩-시-스레드마다-스택과-pc를-독립적으로-할당하는-이유는-무엇인가요)
    * [Thread-Safe란?](#thread-safe란)
        + [Reentrant가 무엇인가요?](#reentrant가-무엇인가요)
    * [Context Switching이 무엇인가요?](#context-switching이-무엇인가요)
- [경쟁 상태란 무엇인가요?](#경쟁-상태란-무엇인가요)
    * [Critical Section(임계영역)과 Critical Section Problem(임계영역 문제)가 무엇인가요?](#critical-section임계영역과-critical-section-problem임계영역-문제가-무엇인가요)
    * [동기화란 무엇인가요?](#동기화란-무엇인가요)
        + [동기화와 관련된 고전적인 문제들을 설명해 주세요.](#동기화와-관련된-고전적인-문제들을-설명해-주세요)
        + [동기화를 제공하는 방식에 대해 설명해 주세요.](#동기화를-제공하는-방식에-대해-설명해-주세요)
        + [스핀락과 뮤텍스의 차이는 무엇인가요?](#스핀락과-뮤텍스의-차이는-무엇인가요)
        + [뮤텍스와 세마포어의 차이는 무엇인가요?](#뮤텍스와-세마포어의-차이는-무엇인가요)
    * [교착상태에 대해 설명해 주세요.](#교착상태에-대해-설명해-주세요)
- [인터럽트가 무엇인가요?](#인터럽트가-무엇인가요)
    * [인터럽트 기능이 없으면 어떤 일이 발생하나요?](#인터럽트-기능이-없으면-어떤-일이-발생하나요)
- [스케줄러란 무엇인가요?](#스케줄러란-무엇인가요)
    * [각 스케줄러의 기능은 무엇인가요?](#각-스케줄러의-기능은-무엇인가요)
        + [Swapping이 무엇인가요?](#swapping이-무엇인가요)
    * [CPU 스케줄러의 목표는 무엇인가요?](#cpu-스케줄러의-목표는-무엇인가요)
    * [CPU 스케줄러(단기 스케줄러)의 종류에 대해 설명해 주세요.](#cpu-스케줄러단기-스케줄러의-종류에-대해-설명해-주세요)
- [동기와 비동기, Blocking과 Non-Blocking은 무엇인가요?](#동기와-비동기-blocking과-non-blocking은-무엇인가요)
- [메모리 관리 기법에 대해서 설명해 주세요.](#메모리-관리-기법에-대해서-설명해-주세요)
    * [연속 메모리 관리와 불연속 메모리 관리에 대해서 설명해 주세요.](#연속-메모리-관리와-불연속-메모리-관리에-대해서-설명해-주세요)
- [가상 메모리는 무엇인가요?](#가상-메모리는-무엇인가요)
    * [가상 주소 공간이 무엇인가요?](#가상-주소-공간이-무엇인가요)
    * [요구 페이징이란 무엇인가요?](#요구-페이징이란-무엇인가요)
    * [페이지 부재와 페이지 교체에 대해 설명해 주세요.](#페이지-부재와-페이지-교체에-대해-설명해-주세요)
    * [페이지 교체 알고리즘은 어떤 것들이 있습니까?](#페이지-교체-알고리즘은-어떤-것들이-있습니까)
        + [LRU 알고리즘과 NUR 알고리즘의 차이점은 무엇인가요?](#lru-알고리즘과-nur-알고리즘의-차이점은-무엇인가요)
        + [Page Reference String은 무엇인가요?](#page-reference-string은-무엇인가요)
    * [MMU가 무엇인가요?](#mmu가-무엇인가요)

</div>
</details>

## 운영체제의 역활은 무엇입니까?

기본적으로 운영체제란 시스템의 자원과 동작을 관리하는 소프트웨어입니다. 이를 크게 역활을 나누면 프로세스 관리, 저장장치 관리, 네트워킹, 사용자 관리, 디바이스 드라이버 등이 있습니다.

##### 참고자료

- https://gyoogle.dev/blog/computer-science/operating-system/Operation System.html

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 커널 모드와 사용자 모드는 무엇인가요?

먼저, 커널이란 운영체제의 핵심 부분으로 다른 모든 부분에 여러 기본적인 서비스를 제공해주는 곳입니다. 해당 영역에선 중요한 자원을 다루기 때문에 사용자가 해당 자원에 접근하지 못하도록(보안성을 위해) 모드를 2가지로 나눈 것이 각각 커널 모드와 사용자 모드입니다. 커널 모드에선 운영체제 내의 모든 자원에 접근, 명령할 수 있습니다. 반면, 유저 모드에선 보안에 해가 되지 않은 영역으로 접근을 제한하고 프로그램 자원에 함부로 침범하지 못하게 합니다. 각 모드로의 전환을 위해 시스템 콜이 사용됩니다.

##### 참고자료

- https://blockdmask.tistory.com/69

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 시스템 콜은 무엇인가요?

운영체제에서 프로그램이 구동되는데 있어 파일을 읽어 오거나, 파일을 쓰거나, 혹은 화면에 메시지를 출력하는 기능들은 커널 모드를 사용합니다. 시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해줍니다. 프로세스 제어, 파일 조작, 장치 조작, 정보 유지보수, 통신과 보호 등이 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 프로세스와 스레드는 무엇인가요?

프로세스는 메모리 상에 실행되고 있는 프로그램의 인스턴스이고, 스레드는 프로세스 안에서 실행되는 여러 흐름의 단위입니다. 가장 기본적인 차이는 프로세스는 자신만의 고유 공간과 지원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간과 자원을 공유하면서 사용합니다. 단, 스택과 PC 레지스터 값은 독립적으로 가지고 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### PCB는 무엇인가요?

프로세스 제어 블록이란 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조입니다. 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성합니다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데, 이 때 작업의 진행 상황을 모두 PCB에 저장하게 됩니다. 향후 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행하게 됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 프로세스의 상태 전이를 설명해 주세요.

![프로세스 상태 전이도](./img/프로세스%20상태%20전이도.png)

프로세스 상태 전이는 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기까지 프로세스의 상태가 생성, 준비, 실행, 대기, 종료 등으로 변하는 것을 말합니다. 기본적으로 프로세스는 생성 후 준비, 실행, 대기를 반복하다가 종료되며, 메모리 부족이나 프로세스가 기억장치를 잃은 경우 스와핑의 과정을 거칩니다.

##### 참고자료

- http://blog.skby.net/프로세스-상태-전이/

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### IPC는 무엇인가요?

기본적으로 프로세스는 독립적으로 실행되지만 프로세스 간의 통신을 해야 하는 상황이 발생했을 때 이를 가능하도록 해주는 것이 바로 IPC통신입니다. 익명 PIPE, Named PIPE, Message Queue, 공유 메모리, 메모리 맵 등이 있습니다.

##### 참고자료

- https://gyoogle.dev/blog/computer-science/operating-system/IPC.html
- https://jwprogramming.tistory.com/54
- https://bluemoon-1st.tistory.com/22

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### IPC 종류와 특징에 대해 설명해 주세요.

- **PIPE** : 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있는 기술입니다. 따라서 반이중 통신이라고도 부릅니다. 익명 PIPE는 통신할 프로세스를 명확히 알 수 있는 경우에 사용합니다. Named PIPE는 전혀 모르는 상태의 프로세스들 사이 통신에 사용됩니다. 즉, 부모와 무관한 다른 프로세스도 통신이 가능합니다. 다만, PIPE는 전이중 통신을 위해서는 2개의 파이프를 설치해야하기에 구현이 복잡합니다.<br>
- **Message Queue** : 입출력 방식은 Named PIPE와 동일합니다. 데이터의 흐름이 아니라 메모리 공간이기에 사용할 데이터에 번호를 붙여 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.<br>
- **공유 메모리** : 데이터 자체를 공유하도록 지원하는 설비입니다. 한 프로세스에서 스레드가 데이터를 공유하는 것과 같은 원리입니다.<br>
- **메모리 맵** : 프로세스의 가상 메모리 주소 공간에 파일을 매핑한 뒤 가상 메모리 주소에 직접 접근하는 방식으로 운영됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 멀티 스레드와 멀티 프로세스가 무엇이고, 각각의 장단점은 무엇인가요?

멀티 스레드는 하나의 프로세스에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것입니다. 그에 반해 멀티 프로세스는 하나의 컴퓨터에 여러 CPU를 장착하여 하나 이상의 프로세스들을 동시에 처리하는 것입니다. 멀티 스레드는 공유메모리 덕분에 독립적인 프로세스에 비해 시간과 자원의 손실이 적고, 각 변수에 대한 자료 공유가 용이합니다. 대신 하나의 스레드가 데이터를 망가뜨리면 모든 스레드가 작동 불능 상태가 되는 안정성의 문제가 있습니다. 멀티 프로세스는 메모리 침범 문제를 OS차원에서 해결하기에 안전하지만 각각 독립된 메모리 영역을 가지고 있기에 작업량이 많을수록 오버헤드가 발생합니다. 또한 Context Switching으로 인한 성능 저하(캐시 메모리를 초기화하면서 발생)가 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 멀티 스레딩 시 스레드마다 스택과 PC를 독립적으로 할당하는 이유는 무엇인가요?

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용하는 메모리 공간입니다. 스택이 독립적인 경우 스레드가 독립적인 함수 호출이 가능하다는 것을 의미하기 때문에 스레드의 독립적인 실행 흐름을 추가하기 위해 독립된 스택을 할당합니다.<br>
PC값을 통해 명령어가 어디까지 수행되었는 지를 확인할 수 있습니다. 스레드가 CPU를 할당받았다가 선점당할 경우, 명령어가 연속적으로 수행되지 못하므로 어디까지 명령어가 수행되었는지 기억할 필요가 있기에 PC 레지스터를 독립적으로 할당합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### Thread-Safe란?

멀티 스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수에 접근할 때, 의도한 대로 동작하는 것을 말합니다. 이를 위해서는 임계영역을 동기화 기법으로 제어해줘야 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### Reentrant가 무엇인가요?

동시에 접근해도 언제나 같은 실행 결과를 보장하는 성질입니다. 전역변수를 사용하거나 반환하면 안 되고 호출 시 제공된 매개변수만으로 동작하는 함수를 일컬어 Reentrant하다고 합니다. 이 경우 함수는 Thread-safe하다고 할 수 있습니다. (역은 성립 불가)

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### Context Switching이 무엇인가요?

동작중인 Task가 대기하면서 해당 Task의 상태(Context)를 보관하고, 대기하고 있던 다음 순번의 Task가 동작하면서 이전에 보관했던 상태를 복구하는 과정을 말합니다. 그래서 프로세스 Context Switching이 발생할 경우 CPU는 캐시 메모리를 초기화하는 작업도 거치기에 오버헤드가 발생한다. 반면 스레드 Context Switching는 독립적인 영역만 변경하면 되기에 훨씬 비용이 적습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 경쟁 상태란 무엇인가요?

경쟁 상태 또는 경쟁 조건(Race Condition)이란 두 개 이상의의 Task가 동시에 공유 자원에 접근할 때, Task의 접근 순서에 따라 결과 값이 달라질 수 있는 상황입니다. 이 상황에선 자료의 일관성이 침해될 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### Critical Section(임계영역)과 Critical Section Problem(임계영역 문제)가 무엇인가요?

Critical Section(임계영역)이란 두 개 이상의의 Task가 자원을 공유하는 상황에서, 하나의 Task만 접근할 수 있도록 제한해둔 코드 영역입니다. 여기서 Critical Section Problem(임계영역 문제)란 코드 중 임계영역으로 설정되어야 하지만 설정되지 않았을 때 발생할 수 있는 문제입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 동기화란 무엇인가요?

경쟁 상태를 해결하는 것 즉, 데이터의 일관성을 유지하기 위해 Task들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 방법입니다. 이를 위한 기본 조건으로는 상호배제(Mutual Exclusion), 진행(Process), 한정된 대기(Bounded Waiting)가 필요하며 스핀락, 세마포, 뮤텍스, 모니터 등의 방식이 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### 동기화와 관련된 고전적인 문제들을 설명해 주세요.

경쟁 상태를 해결하기 위한 동기화 모델을 실생활에서의 문제로 묘사한 문제들입니다. 은행 계좌 문제, 독자 저자 문제, 생산자 소비자 문제, 식사하는 철학자 문제 등이 있습니다.

- 은행 계좌 문제 (Back Account Problem)<br>
부모가 은행 계좌에 입금을 하고, 자식이 은행 계좌에서 출금을 할 때, 입금과 출금 과정이 별도로 이루어져야 합니다.<br><br>
**Critical Section** : 은행 계좌


- 독자 저자 문제 (Readers Writers Problem)<br>
독자가 책(공유 데이터베이스)에 쓰여있는 글을 읽고자 하고, 저자는 책에 글을 써서 추가하려 하는 상황에서 생각할 수 있는 문제입니다.<br>
독자가 글을 읽고 있다면, 독자는 추가적으로 글을 읽을 수 있지만, 저자는 글을 쓸 수 없어야 합니다. 반대로, 저자가 글을 쓰고 있다면, 독자는 글을 읽을 수 없으며, 저자 또한 추가적으로 글을 쓸 수 없어야 합니다.<br><br>
**Critical Section** : 책 (공유 데이터베이스)


- 생산자 소비자 문제 (Producer Consumer Problem)<br>
한정 버퍼 문제(Bounded Buffer Problem)라고도 합니다.<br>
생산자는 물건을 생산하여 창고(버퍼)에 넣고, 소비자는 창고에서 물건을 꺼내서 소비합니다. 이때, 창고가 가득 차면 생산자는 물건을 넣을 수 없고, 창고가 비어 있으면 소비자는 물건을 소비할 수 없어야 합니다.<br><br>
**Critical Section** : 창고 (버퍼)


- 식사하는 철학자 문제 (Dining Philosopher Problem)<br>
원형 테이블에 철학자들이 앉아있고 철학자의 수만큼 젓가락이 철학자 사이에 하나씩 놓여 있습니다. 철학자들이 식사를 하기 위해서는 놓여있는 젓가락 중 2개를 들어서 사용해야 합니다. 어떤 철학자가 젓가락을 사용 중이라면, 다른 어떤 철학자는 식사를 할 수 없습니다.<br>
만약 모든 철학자들이 동시에 하나의 젓가락을 든다면 아무도 식사를 할 수 없습니다. (Starvation)<br><br>
**Critical Section** : 젓가락

##### 참고자료

- https://rebas.kr/856
- https://velog.io/@zehye/전통적-동기화-예제생산자-소비자문제-RW문제-식사하는-철학자-문제

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### 동기화를 제공하는 방식에 대해 설명해 주세요.

##### Spinlock
하드웨어 기반 해결책으로써, 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section에 진입하는 프로세스는 Lock을 획득하고 Critical Section을 빠져나올 떼, Lock을 방출함으로써 동시에 접근되지 않도록 하는 방식입니다.  다만 하나의 Task가 무한루프를 돌기 전에 인터럽트가 걸리면 값을 변경하지 못하고 다른 Task가 Lock함수에 들어오게 되므로 상호배제가 위배되는 상황이 발생합니다. 이를 위해 소프트웨어 기반의 해결책이 제시되었으나 멀티 프로세서에서는 시간적인 효율성 측면에서 적용할 수 없습니다. 또한 선점 기간 동안 다른 프로세스의 작업이 지연될 수 있기에 짧게 수행할 수 있는 작업에 사용됩니다.
> Busy Waiting은 무엇입니까?
><br>하나의 Task가 공유 자원을 사용 중일 때, 무한 루프를 돌면서 공유 자원을 사용할 수 있는지 체크하는 방식을 Busy Waiting이라고 한다.

##### Semaphores(세마포)
세마포는 이진 세마포와 카운팅 세마포가 있습니다. 카운팅 세마포는 가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 가용한 자원의 개수로 세마포를 초기화하여 사용합니다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가되는 방식으로 사용됩니다. 이진 세마포는 뮤텍스와 닮았으며, 가용한 자원의 개수가 1개일 때, 즉 세마포가 가질 수 있는 값이 1 과 0뿐일때 이진 세마포라고 합니다.

##### MUTEX(뮤텍스)
임계영역에 들어갈 때 락을 걸어 다른 Task가 접근하지 못하도록 하고, 임계영역에서 나와 해당 락을 해제합니다.

##### Monitor(모니터)
Task 동기화를 위해 구현된 기능 또는 모듈들을 뜻합니다. 주로 고급 언어에서 지원되며 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태입니다. 모니터에서 키의 획득, 해제를 모두 처리하기에 간단한 것이 장점입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### 스핀락과 뮤텍스의 차이는 무엇인가요?

뮤텍스는 다른 병렬적인 Task를 처리하기 위해 CPU를 처리할 수 있다는 것이며, 이를 위해 Context Switching을 하고 자원을 기다릴 수 있습니다. 다만 자원을 단시간에 얻을 수 있게 될 경우 Context Switching에 더 큰 자원을 소모할 수 있습니다.<br>
이와 반대로 스핀락은 Busy Waiting의 문제가 발생하지만 단기간에 자원을 얻을 수 있다면 Context Switching비용이 들지 않으므로 효율을 높일 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### 뮤텍스와 세마포어의 차이는 무엇인가요?

먼저 가질 수 있는 변수의 크기가 다릅니다. 또한 Locking 매커니즘을 사용하는 뮤텍스는 락을 획득한 프로세스가 반드시 그 락을 해제해야 하지만 Signaling 매커니즘을 하용하는 세마포어는 다른 프로세스가 Signal을 이용해 락을 해제할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 교착상태에 대해 설명해 주세요.

교착 상태란 스레드가 각각의 객체의 락이 풀리기를 기다리면서 무한 대기 상태에 빠진것을 말합니다. 이를 위해선 상호 배제, 점유 대기, 비선점, 순환 대기의 4가지 조건이 필요합니다. 교착 상태를 처리하지 위해선 예방, 회피, 탐지 및 회복의 방식이 이용됩니다. 예방은 상기 4가지의 조건이 만족되지 않으면 교착 상태에 빠지지 않으므로 조건 중 하나를 제거하면서 해결하는 방안이고, 회피로는 대표적으로 은행원 알고리즘이 있습니다. 마지막으로 탐지 및 회복은 교착 상태가 되도록 허용한 다음 교착 상태가 발생하면 이를 탐지하고 회복시키는 방안이 있습니다.

> 은행원 알고리즘이란?
><br>은행원이 돈이 필요한 모든 고객의 요구가 충족되도록 빌려줄 수 있고, 빌릴 수 있는 사람에게 현금을 할당하는데서 유래한 알고리즘 입니다. 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아 있게 되는지 사전에 검사하여 교착 상태를 회피하는 알고리즘입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 인터럽트가 무엇인가요?

프로그램 실행 도중 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고, 발생된 상황을 우선 처리 후 실행 중이던 작업으로 복귀하여 처리를 이어 나가는 것입니다. 크게 내/외부 인터럽트, 소프트웨어 인터럽트가 있고, 내/외부 인터럽트는 CPU의 하드웨어 신호에 의해 발생하며, 소프트웨어 인터럽트는 명령어의 수행에 의해 발생하는 것입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 인터럽트 기능이 없으면 어떤 일이 발생하나요?

이 경우 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 주기적으로 체크(폴링-Polling)해야합니다. 폴링 시에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못한다는 단점이 존재합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 스케줄러란 무엇인가요?

한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할을 하는 것을 스케줄러라고 합니다. 이를 위해 Job queue, Ready queue, Device queue의 3가지 Queue가 있고, 스케줄러 자체는 크게 장기, 단기, 중기 스케줄러로 나뉩니다. 다만 최근에는 가상메모리의 등장으로 장기와 중기 스케줄러는 활용도가 낮아졌습니다.
> 각 Queue의 역활
><br>**Job queue** : 현재 시스템 내에 있는 모든 프로세스의 집합
><br>**Ready queue** : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
><br>**Device queue** : Device I/O 작업을 기다리고 있는 프로세스의 집합

##### 참고자료

- https://jhnyang.tistory.com/372
- https://girawhale.tistory.com/62

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 각 스케줄러의 기능은 무엇인가요?

장기 스케줄러는 Job queue에서 Ready queue에 올릴 프로세스를 선별하는 스케줄러입니다. CPU bound process와 I/O bound process를 적절히 Ready queue에 올립니다. 단기 스케줄러는 Ready queue에서 어떤 프로세스를 먼저 running 할 지 결정하는 스케줄러입니다. 마지막으로 중기 스케줄러는 여유공간 마련을 위해 프로세스를 메모리에서 디스크로 쫓아내는 역활을 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### Swapping이 무엇인가요?

각각의 프로세스는 독립된 메모리 공간을 가지고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려 있습니다. 운영체제만 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제한을 받지 않는데, (운영체제가 정한 주기마다) 스케줄링 정책에 따라 프로세스를 주 메모리에서 보조 메모리로, 다시 보조 메모리에서 주 메모리로 이동시키는 것을 Swapping이라고 합니다.

##### 참고자료

- https://jhnyang.tistory.com/103?category=815411

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### CPU 스케줄러의 목표는 무엇인가요?

CPU 스케줄링의 목표는 크게 Batch System, Interactive System, Real-time System이 있습니다. 가능하면 많은 일을 수행하고, 빠른 응답 시간과 적은 대기 시간을 추구하며, 기한에 맞춰 프로세스가 진행되어야 한다는 것입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### CPU 스케줄러(단기 스케줄러)의 종류에 대해 설명해 주세요.

크게 선점 스케줄링과 비선점 스케줄링이 있습니다. 비선점 스케줄링은 프로세스가 종료되거나 I/O 이벤트가 있을 때까지 실행을 보장받는 방법이며,  선점 스케줄링은 프로세스가 CPU 사용권을 선점할 수 있는 경우 강제 회수하는 방법입니다. 비선점 스케줄링에는 FCFS, SJF 등이 있으며, 선점 스케줄링에는 Priority Scheduling, Round Robin, Multilevel-Queue, Multilevel-Feedback-Queue 등이 있습니다.

- **FCFS(First-Come, First-Served)** : 가장 먼저 도착한 프로세스를 먼저 서비스 해주는 방식입니다. 가장 간단하고 공평하지만 Convey Effect(burst time이 긴 프로세스가 먼저 도착해 효율성이 떨어지는 현상)가 발생합니다.
- **SJF(Shortest Job First)** : 실행 시간(Burst Time)이 가장 짧은 작업을 먼저 서비스 해주는 방식입니다. 실행 시간을 예측하기 위한 오버헤드가 발생하고 Starvation이 생길 수 있다. (선점식으로 운용되는 것이 SRTF이다)

- **Priority Scheduling** : 우선순위가 높은 것을 먼저 서비스 해주는 방식입니다. 우선 순위 부여에 Time Limit이 짧고, Memory를 작게 차지하고, CPU Time이 짧은 프로세스의 우선순위를 높여주는 방식이 있습니다. 마찬가지로 Starvation이 단점입니다. 이를 위해 Aging기법이 적용될 수 있습니다.
- **Round-Robin** : Time Quantum(=Time Slice)을 최대 수행시간으로 하여 CPU가 실행하는 Process를 Switching하는 방식입니다. 이는 시분할 시스템(Time Sharing System)에서 많이 사용되는 방법입니다. Time Quantum에 Performance가 의존하므로 적절한 Time Quantum을 잡는 것이 중요합니다.
- **Multilevel-Queue-Scheduling** : 단일한 Ready queue가 아닌 우선 순위마다 각각의 Ready queue를 만들어서 스케줄링하는 방식입니다. 각 큐는 RR에 의해 스케줄링 되고, 상위 큐를 비우면 하위 큐가 실행되는 방식입니다
- **Multilevel-Feedback-Queue-Scheduling** : Multilevel-Queue-Scheduling를 강화한 형태로 큐와 큐 사이의 이동을 허용합니다. 따라서 낮은 우선 순위을 큐에서 프로세스가 너무 오랫동안 대기하고 있는 상태라면 한 단계 위의 우선 순위 큐로 올릴 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 동기와 비동기, Blocking과 Non-Blocking은 무엇인가요?

동기는 함수를 실행을 하고 호출한 함수에서 작업완료를 신경 쓰는 것을 의미합니다. 반면 비동기는 요청에대한 return만 받고 향후 호출된 callback함수가 작업 완료를 신경씁니다. Blocking은 요청한 작업이 마칠 때까지 계속 대기하는 것이고, Non-Blocking은 요청한 작업을 즉시 마칠 수 없다면 즉시 return하는 것입니다.

##### 참고자료

- https://velog.io/@wonhee010/동기vs비동기-feat.-blocking-vs-non-blocking
- https://youtu.be/IdpkfygWIMk

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 메모리 관리 기법에 대해서 설명해 주세요.

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 한정된 메모리를 여러 프로세스가 함께 메모리를 사용하기에 효율적인 관리를 위한 여러 기법이 필요합니다. 크게 연속 메모리 관리와 불연속 메모리 관리가 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 연속 메모리 관리와 불연속 메모리 관리에 대해서 설명해 주세요.

연속 메모리 관리는 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당하는 기법입니다. 이 경우 메모리에 적재되고 제거되는 일이 반복되다 보면, 프로세스들이 사용하지 못하는 작은 자유 공간들이 늘어나게 되는 단편화 현상이 일어납니다. 고정적으로 메모리를 분할할 경우 내부 단편화가, 동적으로 분할할 경우 외부 단편화가 주로 일어납니다. 이를 해결하기 위해 압축이라는 기법이 존재하지만 작업효율이 좋지 않습니다.<br>
이와 달리, 불연속 메모리 관리는 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애고 서로 다른 주소 공간에 할당하는 기법입니다. 대표적으로 페이징과 세그멘테이션이 있습니다. 페이징은 메모리를 고정된 크기를 가진 프레임으로 분리한 후 이에 맞추어 프로세스의 논리 메모리를 페이지라 불리는 고정크기의 블록으로 분리하여 각 프레임에 mapping하는 방법입니다. 외부단편화는 해결할 수 있지만 내부 단편화의 문제가 발생할 수 있습니다. 세그멘테이션은 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적인 단위인 세그먼트로 분할하여 사용자가 세그먼트 번화와 변위를 지정하고, 세그멘트 테이블에 각 세그멘트의 기준과 한계를 저장합니다. 내부 단편화의 문제는 해결할 수 있지만 외부 단편화의 문제가 발생할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## 가상 메모리는 무엇인가요?

다중 프로그래밍을 실현하기 위해 많은 프로세스들을 동시에 메모리에 올려두어야 합니다. 하지만 메모리의 크기에는 한계가 있기에 제안된 것이 가상 메모리입니다. 프로세스 전체가 메모리 내에 올라 오지 않더라도 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 가상 주소 공간이 무엇인가요?

한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간입니다. 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로서, 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 요구 페이징이란 무엇인가요?

가상 메모리 시스템에서 많이 사용되는, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라고 합니다. 실행과정에서 필요해질 때 페이지들을 적재합니다. 개별 페이지들은 페이저에 의해 관리됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 페이지 부재와 페이지 교체에 대해 설명해 주세요.

페이지 부재(Page Fault)는 CPU에서 요청한 페이지가 현재 메모리에 없는 경우를 말합니다. 이 때 부재 페이지를 디스크에서 읽어와야 하는데 막대한 오버헤드가 발생합니다. 페이지 부재 발생 시 메모리에 해당 페이지를 적재해야 하지만 메모리가 꽉 찬 경우 가장 쓸모 없는 페이지를 쫓아내고 그 자리에 부재된 페이지를 적재하는 것이 페이지 교체입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### 페이지 교체 알고리즘은 어떤 것들이 있습니까?

FIFO, 최적 페이지 교체, LRU(Least Recently Used) 페이지 교체, LFU(Least Frequently Used) 페이지 교체, MFU(Most Frequently Used) 페이지 교체 등이 있습니다.

- **FIFO 페이지 교체** : 가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가집니다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 되는 것입니다. 이해하기도 쉽고, 프로그램하기도 쉽습니다. 하지만 오래된 페이지가 초기 변수 등 항상 불필요하지 않은 정보를 포함하지 않을 수 있으며, 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수도 있습니다.
- **최적(Optimal) 페이지 교체** : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것입니다. 주로 비교 연구 목적을 위해 사용합니다. 알고리즘 중 가장 낮은 페이지 부재율을 보장하지만, 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기에 앞으로 잘 사용되지 않는다는 보장을 가질 수 없기에 구현이 어렵습니다.
- **LRU 페이지 교체** : 최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체합니다. 실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높기에 가장 현실적은 방법 중 하나입니다.
- **LFU 페이지 교체** : 참조 횟수가 가장 적은 페이지를 교체하는 방법입니다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘입니다. 하지만 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있습니다
- **MFU 페이지 교체** : 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에서 만들어진 알고리즘입니다. 하지만 마찬가지로 오랫동안 사용되지 않기에 참조되지 않은 페이지가 계속 메모리에 머물게 되어 초기 가정에 어긋하는 시점이 발생할 수 있습니다. 또한 한창 집중적으로 사용되던 페이지가 교체되어 페이지 부재율을 상승시킬 수 있습니다.
- LFU와 MFU 모두 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### LRU 알고리즘과 NUR 알고리즘의 차이점은 무엇인가요?

페이지의 사용량을 추적하는 방식에서 다릅니다. NUR 알고리즘은 LRU 알고리즘이 이론상으론 가장 최적의 성능을 제공하지만 실제 구현하는 데의 비용이 많기에 제시된 LRU 근사 알고리즘입니다. LRU 알고리즘은 현 시점까지 참조된 페이지 번호 순서를 거꾸로 검사하여 중복되지 않고 가장 나중에 나타나는 페이지를 선택하는 방식이기에 모든 페이지를 순회하여야 합니다. 반면 NUR 알고리즘은 주기적으로 참조비트를 클리어합니다. 그리고 해당 주기 안에 참조된 페이지는 참조비트를 1로 설정합니다. 페이지 부재 시 가장 낮은 우선 순위의 페이지들 가운데서 랜덤으로 페이지를 교체합니다. 따라서 순회의 비용이 줄어들기 때문에 LRU 알고리즘을 대체하는데 사용됩니다.

##### 참고자료

- https://velog.io/@adam2/OS기초-메모리-관리가상-메모리-페이지-부재-페이지-교채-스레싱

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

#### Page Reference String은 무엇인가요?

메인 메모리에 올라와 있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 페이지 결함이 발생하지 않습니다. 따라서 CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분(연속된 부분)은 생략하여 표시하는 방법입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

### MMU가 무엇인가요?

메모리 관리장치는 논리 주소를 물리 주소로 변환해주는 장치입니다. 명령어 수행 시 메모리에 필요한 데이터가 없을 때 해당 데이터를 가져오는 역활을 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#운영체제os)**

## ETC

<details>
 <summary><strong>한정적인 시간 가운데 선택적으로 공부하지 않은 내용입니다.</strong></summary>
 <div markdown = "1">

>시간적 여유가 있을 때 보충예정

- [시스템 콜 예시](https://gyoogle.dev/blog/computer-science/operating-system/System%20Call.html)

</div>
</details>