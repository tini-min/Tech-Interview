# Computer Architecture

<details>
 <summary><strong>용어 정리 (기초용어)</strong></summary>
 <div markdown = "1">

- https://brunch.co.kr/@toughrogrammer/14

</div>
</details>

<details>
 <summary><strong>목차</strong></summary>
 <div markdown = "1">

- [하드웨어의 구성에 대해 설명해 주세요.](#하드웨어의-구성에-대해-설명해-주세요)
    * [RAM에서 Random이 의미하는 바가 무엇인가요?](#ram에서-random이-의미하는-바가-무엇인가요)
    * [SSD와 HDD의 차이점은?](#ssd와-hdd의-차이점은)
    * [시스템 버스는 무엇인가요?](#시스템-버스는-무엇인가요)
- [CPU의 동작은 어떤 과정으로 이뤄지나요?](#cpu의-동작은-어떤-과정으로-이뤄지나요)
    * [명렁어 사이클이 무엇인가요?](#명렁어-사이클이-무엇인가요)
    * [인출 사이클과 실행 사이클에 의한 명령어 처리과정에 대해 설명해 주세요.](#인출-사이클과-실행-사이클에-의한-명령어-처리과정에-대해-설명해-주세요)
    * [간접 사이클과 인터럽트 사이클에 의한 명령어 처리과정에 대해 설명해 주세요.](#간접-사이클과-인터럽트-사이클에-의한-명령어-처리과정에-대해-설명해-주세요)
- [파이프라이닝이 무엇인가요?](#파이프라이닝이-무엇인가요)
    * [파이프라인 해저드가 무엇인가요?](#파이프라인-해저드가-무엇인가요)
    * [파이프라인 해저드를 해결하기 위한 방안은 무엇인가요?](#파이프라인-해저드를-해결하기-위한-방안은-무엇인가요)
- [캐시 메모리는 무엇인가요?](#캐시-메모리는-무엇인가요)
    * [캐시 메모리의 작동 원리에 대해 설명해 주세요.](#캐시-메모리의-작동-원리에-대해-설명해-주세요)
    * [Cache Miss의 종류 3가지에 대해 설명해 주세요.](#Cache-Miss의-종류-3가지에-대해-설명해-주세요)
    * [캐시 메모리에서 사상이 무엇이고 사상 방식에 대해 설명해 주세요.](#캐시-메모리에서-사상이-무엇이고-사상-방식에-대해-설명해-주세요)
    * [캐시 메모리의 데이터가 업데이트 되었을 경우 취할 수 있는 방법에 대해서 설명해 주세요.](#캐시-메모리의-데이터가-업데이트-되었을-경우-취할-수-있는-방법에-대해서-설명해-주세요)
- [해밍코드 생성 및 해석 해보기](#해밍코드-생성-및-해석-해보기)
- [보수를 사용하는 이유가 무엇인가요?](#보수를-사용하는-이유가-무엇인가요)
    * [1의 보수와 2의 보수를 설명해 주세요.](#1의-보수와-2의-보수를-설명해-주세요)
- [ARM 프로세서는 무엇인가요?](#arm-프로세서는-무엇인가요)
    * [CISC와 RISC의 장단점은 무엇인가요?](#CISC와-RISC의-장단점은-무엇인가요)

</div>
</details>

## 하드웨어의 구성에 대해 설명해 주세요.

중앙처리장치(CPU), 기억장치, 입출력장치로 구성되어 있습니다. 각가은 시스템 버스로 연결되어 있으며, 세부사항을 따지면 CPU는 산술논리연산장치(ALU), 제어장치, 레지스터로 구성되어 있습니다. 기억장치는 크게 주기억장치인 RAM, ROM등과 보조기억장치인 하드디스크로 나뉩니다. 저희들이 가장 흔히 볼 수 있는 키보드나 마우스, 모니터 등이 입출력장치에 해당합니다.

<details>
 <summary><strong>CPU, ALU, RAM, ROM의 Full name</strong></summary>
 <div markdown = "1">

- **CPU** : Central Proccecing Unit
- **ALU** : Arithmetic Logic Unit
- **RAM** : Random Access Memory
- **ROM** : Read Only Memory

 </div>
</details>

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### RAM에서 Random이 의미하는 바가 무엇인가요?

RAM은 어느 위치에 저장된 데이터든지 읽기나 쓰기 등의 접근을 하는데 동일한 시간이 걸리는 메모리이기에 '랜덤'이라는 명칭이 부여되어 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### SSD와 HDD의 차이점은?

플래터에 데이터를 기록하는지 반도체 메모리에 데이터를 기록하는지에 따라서 나뉩니다. 기존 HDD의 경우 플레터에 데이터를 읽고 쓰고하는 방식이 물리적인 제약이 존재해 속도 면에서 떨어집니다. 반면 SSD는 가격은 비싸지만 속도도 빠르고 물리적 제약에서 벗어났기 때문에 발열이나 소음 등이 훨씬 덜 발생합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 시스템 버스는 무엇인가요?

하드웨어의 구성요소를 물리적으로 연결하는 선입니다. 용도에 따라서 데이터 버스, 주소 버스, 제어 버스 등이 있습니다. 데이터 버스는 기억장치나 입출력 장치의 명령어와 데이터를 CPU로 보내거나 반대로 CPU에서 연산결과를 기억장치나 입출력 장치에 보내는 양방향 버스입니다. 주소 버스는 CPU가 주 기억장치나 입출력 장치로 주소를 전달하는 단방향 버스입니다. 마지막으로 제어 버스는 CPU, 기억장치, 입출력 장치에 제어 신호를 전달하는 양방향 통로입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## CPU의 동작은 어떤 과정으로 이뤄지나요?

주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어온다 -> CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장한다 -> 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보낸다 -> 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어한다

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 명렁어 사이클이 무엇인가요?

CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동입니다. 명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어 집니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 인출 사이클과 실행 사이클에 의한 명령어 처리과정에 대해 설명해 주세요.

> 인출 사이클

T0 : MAR ← PC
- PC에 저장된 주소를 MAR에 전달합니다.

T1 : MBR ← M[MAR], PC ← PC+1
- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어를 인출하고 인출한 명령을 MBR에 저장합니다. 다음 명령어를 인출하기 위해 PC 값을 증가시킵니다.

T2 : IR ← MBR
- MBR에 저장된 내용을 IR에 전달합니다.

> 실행 사이클

명령어 코드를 해독하고 결과에 따라 연산을 수행합니다. 연산의 종류에는 데이터 이동, 데이터 처리, 데이터 저장, 프로그램 제어 등이 있습니다.

1. Load addr(데이터 이동)<br>
T0 : MAR ← IR(addr)<br>
T1 : MBR ← M[MAR]<br>
T2 : AC ← MBR<br>

1. ADD addr(데이터 처리)<br>
T0 : MAR ← IR(addr)<br>
T1 : MBR ← M[MAR]<br>
T2 : AC ← AC+MBR<br>

1. STA addr(데이터 저장)<br>
T0 : MAR ← IR(addr)<br>
T1 : MBR ← AC<br>
T2 : M[MAR] ← MBR<br>

1. JUMP addr(프로그램 제어)<br>
T0 : PC ← IR(addr)<br>

##### 참고자료

https://blog.naver.com/jaeyoon_95/221053588562

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 간접 사이클과 인터럽트 사이클에 의한 명령어 처리과정에 대해 설명해 주세요.

> 간접 사이클 

addr이 데이터가 저장된 기억장소의 주소를 가르키는 경우 실행 사이클이 시작되기 전에 그 데이터의 실제 주소를 기억장치로 부터 읽어오는 과정이 먼저 수행되어야 합니다. 이 경우 간접 사이클이 수행됩니다.

T0 : MAR ← IR(addr)<br>
T1 : MBR ← M[MAR]<br>
T2 : IR(addr) ← MBR<br>

> 인터럽트 사이클

T0 : MBR ← PC<br>
- 인터럽트가 끝난 뒤 수행되어야 하는 PC값을 MBR에 저장시킵니다.

T1 : MAR ← SP(Stack Pointer), PC ← ISR(Interrupt Service Routine)의 시작 주소<br>
T2 : M[MAR] ← MBR, SP ← SP-1<br>

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## 파이프라이닝이 무엇인가요?

CPU의 속도를 향상시키기 위한 방법 중의 하나로, 명령어를 실행하는 데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하여 서로 다른 명령어들을 동시에 처리하는 기술입니다. 처리 속도가 크게 향상되지만 일명 파이프라인 해저드라고 하는 지연현상이 발생할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 파이프라인 해저드가 무엇인가요?

파이프라인의 진행을 지연, 중지해야 하는 상황을 유발하는 원인입니다. 크게 구조적, 데이터, 제어 해저드가 있습니다. 구조적 해저드는 동일 자원에 대해 2개 이상의 명령어가 동시에 접근하는 문제이며, 데이터 해저드는 한 명령어의 결과가 바로 다음 명령어에서 사용해야 하는 상황이지만 결과가 아직 산출되기 전이라 해당 값을 사용할 수 없는 문제입니다. 마지막으로 제어 해저드는 Branch, Jump 혹은 Call/Return 과 같이 상황에 따라 다음 명령어가 바뀌어 다음에 처리해야 하는 명령어를 판단하기 어려운 문제입니다.

##### 참고자료

- https://jesus-never-fail.tistory.com/13
- https://talkingaboutme.tistory.com/477

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 파이프라인 해저드를 해결하기 위한 방안은 무엇인가요?

구조적 해저드의 해결책은 ALU의 갯수를 늘리거나 메모리를 명령어 영역과 데이터 영역으로 분리해서 사용하는 방법입니다. 데이터 해저드의 경우 이전 명령어의 결과가 나올 때 까지 다음 명령어의 실행을 미루거나, 해당 결과값과 관련이 없는 명령어나 NOP을 해당 명령어 사이에 수행시켜서 다음 명령어의 순서를 미루어 대기 없이 결과값을 받을 수도 있습니다. 혹은 해당 결과를 쓰기 전에 이미 실행된 결과를 MUX를 추가하여 전달(Forwarding)하는 것입니다. 마지막으로 제어 해저드는 (생략 //보충필요)

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## 캐시 메모리는 무엇인가요?

속도가 빠른 장치와 느린 장치의 속도 차에 따른 병목 현상을 줄이기 위한 메모리 입니다. CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장 후 읽어오면 속도가 상승됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 캐시 메모리의 작동 원리에 대해 설명해 주세요.

캐시 메모리는 데이터 지역성의 원리를 이용합니다.  데이터 지역성은 시간 지역성과 공간 지역성 등이 있습니다. 시간 지역성은 for문이나 while문에서 사용하는 조건 변수와 같이 한 번 참조된 데이터는 잠시 후 다시 참조될 가능성이 높다는 것이고, 공간 지역성은 A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 다시 사용될 가능성이 높음을 의미합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### Cache Miss의 종류 3가지에 대해 설명해 주세요.

캐시 미스는 Cold Miss, Conflict Miss, Capacity Miss가 있으며, 각각 해당 메모리 주소를 처음 불러서 발생하는 미스, 캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스, 아니면 아예 캐시 메모리의 공간이 부족해서 발생하는 미스를 뜻합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 캐시 메모리에서 사상이 무엇이고 사상 방식에 대해 설명해 주세요.

주기억장치의 블록을 적재할 캐시의 위치를 지정하는 방법을 사상이라고 합니다. 대표적으로 직접 사상, 연관 사상, 집합 연관 사상이 있습니다. 직접 사상으로 구현된 캐시(Direct Mapped Cache)는 간단하고 빠르다는 장점이 있지만 같은 주소에 지정된 다른 데이터를 이용할 경우 Conflict Miss가 발생하는 것이 단점입니다. 이와는 정 반대로 비어있는 캐시가 있다면 마음대로 주소를 저장하는 방식의 Fully Associative Cache의 경우, 저장은 간편하지만 조건이나 규칙이 없기에 데이터를 검색하는 속도가 느립니다. 이 둘의 절충안으로 제시된 구조가 Set Associative Cache입니다. 특정 행을 지정하고 그 행 안의 어떤 열이든 비어있으면 저장하는 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 캐시 메모리의 데이터가 업데이트 되었을 경우 취할 수 있는 방법에 대해서 설명해 주세요.

캐시 메모리에 저장된 데이터가 변경될 경우 취할 수 있는 방법 중 하나는 변경 사항을 바로 메인 메모리나 보조 메모리에 반영을 하는 것이고, 혹은 나중에 캐시 메모리에서 해당 데이터의 내용을 메인 메모리나 보조 메모리에 반영하는 방법도 있습니다. 업데이트가 생길 때 마다 수정 내용 반영 시, 데이터 일관성이 유지되고, 구현이 쉬운 장점이 있지만 속도면에서는 불리할 수 있습니다. 반면에, 향후 캐시 메모리의 데이터가 교체 될 때 반영하는 경우는 업데이트 여부를 따로 기록해야 하는 등의 구현의 복잡성과 일관성이 보장되지 않을 수 있지만 속도면에서는 유리합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## 해밍코드 생성 및 해석 해보기

##### 참고자료

- https://blog.naver.com/ggggamang/221113176831
- https://dreamlog.tistory.com/578

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## 보수를 사용하는 이유가 무엇인가요?

컴퓨터는 (\-)라는 개념이 없기 때문에 최상위 비트를 부호 비트로 사용합니다. 다만, 1 + (\-1)의 계산의 결과가 0이 나와야 하지만 실제 계산에선 1 + (\-1) = 0001<sub>(2)</sub> + 1001<sub>(2)</sub> = 1010<sub>(2)</sub> = \-2가 나옵니다. 따라서, 이를 보완하기 위해 나온 방법이 보수입니다. 보수를 이용하면 감산기를 사용하지 않고 덧셈 연산을 통해 뺄셈을 구현할 수 있습니다.

##### 참고자료

- https://kjhweb.tistory.com/40

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### 1의 보수와 2의 보수를 설명해 주세요.

1의 보수는 0을 1로, 1을 0으로 표현한 방식입니다. -1 = 1110<sub>(2)</sub>이므로, 1 + (\-1) = 0001<sub>(2)</sub> + 1110<sub>(2)</sub> = 1111<sub>(2)</sub> = (\-0)입니다. 다만, 이 경우 \-7과 구분이 되지 않습니다.<br>
> 실제 계산 시, (\-1) + (\-6) = 1110<sub>(2)</sub> + 1001<sub>(2)</sub> = 1 0111<sub>(2)</sub> 이므로 다르지만 캐리가 발생하였는 지를 확인하는 작업이 필요합니다.

이를 개선한 방식이 2의 보수입니다. 1의 보수의 방식을 취한 후 1을 더해줍니다. 따라서, 1 + (\-1) = 0001<sub>(2)</sub> + 1111<sub>(2)</sub> = 1 0000<sub>(2)</sub>이며 최상위 비트가 범위를 벗어나므로 이를 무시하면 0000<sub>(2)</sub> = 0의 결과값을 얻을 수 있습니다.

- 예시(2의 보수)

    |10진수|2진수|10진수|2진수|
    |:---:|:---:|:---:|:---:|
    |0|0000<sub>(2)</sub>|
    |1|0001<sub>(2)</sub>|\-1|1111<sub>(2)</sub>|
    |2|0010<sub>(2)</sub>|\-2|1110<sub>(2)</sub>|
    |3|0011<sub>(2)</sub>|\-3|1101<sub>(2)</sub>|
    |4|0100<sub>(2)</sub>|\-4|1100<sub>(2)</sub>|
    |5|0101<sub>(2)</sub>|\-5|1011<sub>(2)</sub>|
    |6|0110<sub>(2)</sub>|\-6|1010<sub>(2)</sub>|
    |7|0111<sub>(2)</sub>|\-7|1001<sub>(2)</sub>|

2의 보수는 굳이 캐리 발생 여부를 확인하지 않고 단순히 무시함으로써 원하는 결과를 얻을 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**
## ARM 프로세서는 무엇인가요?

ARM은 Advanced RISC Machine의 약자로 진보된 RISC 기기입니다. 이중 RISC란 Reduced Instruction Set Computing로서, 단순한 명령 집합을 가진 프로세서가 복잡한 명령 집합을 가진 프로세서보다 훨씬 더 효율적일 것이란 것을 전제한 개념입니다.<br>
단순한 명령 집합과 구조를 가졌기에 프로세서가 작고, 상대적으로 느리지만 효율적입니다. 또한 단순한 명령 집합이 적은 수의 트랜지스터로 이어지기에 다이의 크기를 축소시킬 수 있습니다. 나아가 개별 반도체 제조사 별로 물리적 설계는 같지만 명령 집합이 다르기에 서로 다른 칩이 되기도 합니다. 하지만 하나의 ARM 기기에 작동하는 OS는 다른 ARM기반 기기에서도 잘 작동합니다. 이러한 장점 덕분에 수많은 버전의 OS 생성 및 호환이 가능합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

### CISC와 RISC의 장단점은 무엇인가요?

CISC는 Complex Instruction Set Computer의 약자로 말 그대로 복잡한 명령어로 구성된 집합을 사용하는 것입니다. 반면에, RISC는 Reduced Instruction Set Computer의 약자로 간단한 명령어 집합을 사용합니다. 따라서 나타나지는 장단점으로는, CISC는 컴파일러 작성이 용이하고, 효율이 좋습니다. 다만 하나의 명령어가 복잡하기에 디코딩이 오래 걸리고, 일부 명령어만 주로 쓰입니다. 또한 각 명령어의 길이가 다르기에 동시에 여려 명령어 처리는 어렵습니다. RISC는 복잡한 명령을 보유하고 있는 명령어를 조합하여 처리하기에 컴파일러의 최적화 과정이 복잡해지고, 명령어 길이가 고정되어 있어 코드 효율이 낮지만, 파이프라인의 성능이 최적화 되고, 디코딩 속도가 빠르며, 여러 명령어를 동시에 처리할 수 있는 장점이 있습니다.

##### 참고자료

- https://skagh.tistory.com/7

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#computer-architecture)**

## ETC

<details>
 <summary><strong>한정적인 시간 가운데 선택적으로 공부하지 않은 내용입니다.</strong></summary>
 <div markdown = "1">

>시간적 여유가 있을 때 보충예정

- 부동소수점 표현 방식 (ex. IEEE 754)

</div>
</details>