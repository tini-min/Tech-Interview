1. 하드웨어의 구성은?

중앙처리장치(CPU), 기억장치, 입출력장치로 구성되어 있습니다.
각가은 시스템 버스로 연결되어 있으며, 세부사항을 따지면 CPU는 산술논리연산장치(ALU), 제어장치, 레지스터로 구성되어 있습니다.
기억장치는 크게 주기억장치인 RAM, ROM등과 보조기억장치인 하드디스크로 나뉩니다.
저희들이 가장 흔히 볼 수 있는 키보드나 마우스, 모니터 등이 입출력장치에 해당합니다.

1-1. CPU, ALU, RAM, ROM 등은 무엇의 약자일까?

-> Central Proccecing Unit
-> Arithmetic Logic Unit
-> Random Access Memory
-> Read Only Memory

1-2. RAM에서 Random이 의미하는 바는?

RAM은 어느 위치에 저장된 데이터든지 읽기나 쓰기 등의 접근을 하는데 동일한 시간이 걸리는 메모리이기에 '랜덤'이라는 명칭이 부여되어 있습니다.

1-3. SSD와 HDD의 차이점은?

플래터에 데이터를 기록하는지 반도체 메모리에 데이터를 기록하는지에 따라서 나뉩니다. 기존 HDD의 경우 플레터에 데이터를 읽고 쓰고하는 방식이 물리적인 제약이 존재해 속도 면에서 떨어집니다. 반면 SSD는 가격은 비싸지만 속도도 빠르고 물리적 제약에서 벗어났기 때문에 발열이나 소음 등이 훨씬 덜 발생합니다.

1-4. 시스템 버스란?

하드웨어의 구성요소를 물리적으로 연결하는 선입니다. 용도에 따라서 데이터 버스, 주소 버스, 제어 버스 등이 있습니다. 데이터 버스는 기억장치나 입출력 장치의 명령어와 데이터를 CPU로 보내거나 반대로 CPU에서 연산결과를 기억장치나 입출력 장치에 보내는 양방향 버스입니다. 주소 버스는 CPU가 주 기억장치나 입출력 장치로 주소를 전달하는 단방향 버스입니다. 마지막으로 제어 버스는 CPU, 기억장치, 입출력 장치에 제어 신호를 전달하는 양방향 통로입니다.

2. CPU의 동작 과정은?

주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어온다 -> CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장한다 -> 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보낸다 -> 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어한다

2-1. 명렁어 사이클이란?

CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동입니다. 명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어 집니다.

2-2. 인출 사이클과 실행 사이클에 의한 명령어 처리과정은? (참고 https://blog.naver.com/jaeyoon_95/221053588562 -> 추가적인 CPU구조 O)

인출 사이클

T0 : MAR ← PC
PC에 저장된 주소를 MAR에 전달합니다.
T1 : MBR ← M[MAR], PC ← PC+1
저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어를 인출하고 인출한 명령을 MBR에 저장합니다. 다음 명령어를 인출하기 위해 PC 값을 증가시킵니다.
T2 : IR ← MBR
MBR에 저장된 내용을 IR에 전달합니다.

실행 사이클

명령어 코드를 해독하고 결과에 따라 연산을 수행합니다. 연산의 종류에는 데이터 이동, 데이터 처리, 데이터 저장, 프로그램 제어 등이 있습니다.
- Load addr(데이터 이동)
T0 : MAR ← IR(addr)
T1 : MBR ← M[MAR]
T2 : AC ← MBR

- ADD addr(데이터 처리)
T0 : MAR ← IR(addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC+MBR

- STA addr(데이터 저장)
T0 : MAR ← IR(addr)
T1 : MBR ← AC
T2 : M[MAR] ← MBR

- JUMP addr(프로그램 제어)
T0 : PC ← IR(addr)

2-3. 간접 사이클과 인터럽트 사이클에 의한 명령어 처리과정은?

간접 사이클 

T0 : MAR ← IR(addr)
T1 : MBR ← M[MAR]
T2 : IR(addr) ← MBR
addr이 데이터가 저장된 기억장소의 주소를 가르키는 경우 실행 사이클이 시작되기 전에 그 데이터의 실제 주소를 기억장치로 부터 읽어오는 과정이 먼저 수행되어야 합니다. 이 경우 간접 사이클이 수행됩니다.

인터럽트 사이클

T0 : MBR ← PC
인터럽트가 끝난 뒤 수행되어야 하는 PC값을 MBR에 저장시킵니다.
T1 : MAR ← SP(Stack Pointer), PC ← ISR(Interrupt Service Routine)의 시작 주소
T2 : M[MAR] ← MBR, SP ← SP-1

3. 캐시 메모리란?

속도가 빠른 장치와 느린 장치의 속도 차에 따른 병목 현상을 줄이기 위한 메모리 입니다. CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장 후 읽어오면 속도가 상승됩니다.

3-1. 캐시 메모리의 작동 원리는?

캐시 메모리는 데이터 지역성의 원리를 이용합니다.  데이터 지역성은 시간 지역성과 공간 지역성 등이 있습니다. 시간 지역성은 for문이나 while문에서 사용하는 조건 변수와 같이 한 번 참조된 데이터는 잠시 후 다시 참조될 가능성이 높다는 것이고, 공간 지역성은 A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 다시 사용될 가능성이 높음을 의미합니다.

3-2. Cache Miss 3가지에 대해 설명하시오.

캐시 미스는 Cold Miss, Conflict Miss, Capacity Miss가 있으며, 각각 해당 메모리 주소를 처음 불러서 발생하는 미스, 캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스, 아니면 아예 캐시 메모리의 공간이 부족해서 발생하는 미스를 뜻합니다.

3-3. 캐시 메모리에서 사상이 무엇이고 사상 방식에 대해 설명해 주세요.

주기억장치의 블록을 적재할 캐시의 위치를 지정하는 방법을 사상이라고 합니다. 대표적으로 직접 사상, 연관 사상, 집합 연관 사상이 있습니다. 직접 사상으로 구현된 캐시(Direct Mapped Cache)는 간단하고 빠르다는 장점이 있지만 같은 주소에 지정된 다른 데이터를 이용할 경우 Conflict Miss가 발생하는 것이 단점입니다. 이와는 정 반대로 비어있는 캐시가 있다면 마음대로 주소를 저장하는 방식의 Fully Associative Cache의 경우, 저장은 간편하지만 조건이나 규칙이 없기에 데이터를 검색하는 속도가 느립니다. 이 둘의 절충안으로 제시된 구조가 Set Associative Cache입니다. 특정 행을 지정하고 그 행 안의 어떤 열이든 비어있으면 저장하는 방식입니다.

4. 해밍코드 생성 및 해석 해보기

5. ARM 프로세서란 무엇인가?

ARM은 Advanced RISC Machine의 약자로 진보된 RISC 기기입니다. 이중 RISC란 Reduced Instruction Set Computing로서, 단순한 명령 집합을 가진 프로세서가 복잡한 명령 집합을 가진 프로세서보다 훨씬 더 효율적일 것이란 것을 전제한 개념입니다.
단순한 명령 집합과 구조를 가졌기에 프로세서가 작고, 상대적으로 느리지만 효율적입니다. 또한 단순한 명령 집합이 적은 수의 트랜지스터로 이어지기에 다이의 크기를 축소시킬 수 있습니다. 나아가 개별 반도체 제조사 별로 물리적 설계는 같지만 명령 집합이 다르기에 서로 다른 칩이 되기도 합니다. 하지만 하나의 ARM 기기에 작동하는 OS는 다른 ARM기반 기기에서도 잘 작동합니다. 이러한 장점 덕분에 수많은 버전의 OS 생성 및 호환이 가능합니다.