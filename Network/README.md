# Network

<details>
 <summary><strong>용어 정리 (기초용어)</strong></summary>
 <div markdown = "1">

- **프로토콜** : 컴퓨터 간에 정보를 주고 받을 때의 통신 방법에 대한 규칙이나 표준입니다.

</div>
</details>

<details>
 <summary><strong>목차</strong></summary>
 <div markdown = "1">

- [OSI 7계층이 무엇이고 이를 나누는 이유가 무엇입니까?](#osi-7계층이-무엇이고-이를-나누는-이유가-무엇입니까)
    * [OSI 7계층의 각 계층을 설명해 주세요.](#osi-7계층의-각-계층을-설명해-주세요)
    * [전이중 통신과 반이중 통신이 무엇입니까?](#전이중-통신과-반이중-통신이-무엇입니까)
    * [ARP 캐시가 무엇입니까?](#arp-캐시가-무엇입니까)
- [TCP와 UDP의 장단점을 설명해 주세요.](#tcp와-udp의-장단점을-설명해-주세요)
    * [가상회선 패킷 교환과 데이터그램 패킷 교환은 무엇인가요?](#가상회선-패킷-교환과-데이터그램-패킷-교환은-무엇인가요)
    * [3-way 핸드셰이크와 4-way 핸드셰이크를 설명해 주세요.](#3-way-핸드셰이크와-4-way-핸드셰이크를-설명해-주세요)
        + [3-way Handshake에서 서버도 클라이언트의 ACK 패킷을 기다리는 이유는 무엇인가요?](#3-way-handshake에서-서버도-클라이언트의-ack-패킷을-기다리는-이유는-무엇인가요)
    * [SYN Flooding이 무엇이며 이를 방어하는 방법은 무엇입니까?](#syn-flooding이-무엇이며-이를-방어하는-방법은-무엇입니까)
    * [TCP 연결이 수립되고 실제로 데이터를 보내는 방식을 설명하고 이를 효율적으로 하기 위해서 제안된 방식이 무엇인가요?](#tcp-연결이-수립되고-실제로-데이터를-보내는-방식을-설명하고-이를-효율적으로-하기-위해서-제안된-방식이-무엇인가요)
    * [TCP에서 흐름제어와 혼잡제어가 무엇입니까?](#tcp에서-흐름제어와-혼잡제어가-무엇입니까)
- [TCP/IP(Transmission Control Protocol / Internet Protocol) 모델이 무엇입니까?](#tcp/iptransmission-control-protocol-/-internet-protocol-모델이-무엇입니까)
- [HTTP와 HTTPS는 무엇인가요?](#http와-https는-무엇인가요)
    * [HTTP의 GET과 POST에 대해 설명해 주세요.](#http의-get과-post에-대해-설명해-주세요)
    * [조회에 POST보다 GET이 사용되는 이유는 무엇인가요?](#조회에-post보다-get이-사용되는-이유는-무엇인가요)
    * [HTTP Method에서 PUT과 PATCH의 차이점을 설명해 주세요.](#http-method에서-put과-patch의-차이점을-설명해-주세요)
    * [단방향 암호화와 양방향 암호화는 무엇인가요?](#단방향-암호화와-양방향-암호화는-무엇인가요)
        + [대칭키와 공개키는 무엇입니까?](#대칭키와-공개키는-무엇입니까)
    * [쿠키와 세션이 무엇이며, 필요한 이유가 무엇인가요?](#쿠키와-세션이-무엇이며-필요한-이유가-무엇인가요)
- [소켓 프로그래밍이란 무엇인가요?](#소켓-프로그래밍이란-무엇인가요)
    * [클라이언트 소켓과 서버 소켓이 무엇인가요?](#클라이언트-소켓과-서버-소켓이-무엇인가요)
    * [소켓 API의 실행 흐름에 대해서 설명해 주세요.](#소켓-api의-실행-흐름에-대해서-설명해-주세요)
    * [HTTP 통신과 소켓 통신의 장단점을 설명해 주세요.](#http-통신과-소켓-통신의-장단점을-설명해-주세요)
- [웹 브라우저에 URL을 입력하면 일어나는 시나리오에 대해 설명해 주세요.](#웹-브라우저에-url을-입력하면-일어나는-시나리오에-대해-설명해-주세요)
    * [DNS 동작 방식을 설명해 주세요.](#dns-동작-방식을-설명해-주세요)
    * [프록시 서버란 무엇인가요?](#프록시-서버란-무엇인가요)
- [네트워크 바이트 오더가 무엇입니까?](#네트워크-바이트-오더가-무엇입니까)
    * [빅엔디안과 리틀엔디안이 무엇이고, 각각의 장단점은 무엇입니까?](#빅엔디안과-리틀엔디안이-무엇이고-각각의-장단점은-무엇입니까)
- [로드 밸런싱이 무엇인가요?](#로드-밸런싱이-무엇인가요)
    * [로드 밸런서가 서버를 선택하는 방식을 설명해 주세요.](#로드-밸런서가-서버를-선택하는-방식을-설명해-주세요)
    * [L4 로드 밸런서와 L7 로드 밸런서에 대해 설명해 주세요.](#l4-로드-밸런서와-l7-로드-밸런서에-대해-설명해-주세요)
- [REST(REpresentational State Transfer)란 무엇인가요?](#restrepresentational-state-transfer란-무엇인가요)
    * [RESTful API란 무엇인가요?](#restful-api-무엇인가요)

</div>
</details>

## OSI 7계층이 무엇이고 이를 나누는 이유가 무엇입니까?

OSI7계층은 국제표준화기구에서 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것입니다. 통신이 일어나는 과정을 단계별로 이해하기 쉽고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기에 사용합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### OSI 7계층의 각 계층을 설명해 주세요.

각 계층은 하위 단계부터 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층 순으로 존재합니다. 일반적으로 물리부터 전송 계층은 하드웨어로, 그 위의 상위 계층은 소프트웨어로 구현됩니다.

##### 1) 물리 계층
데이터를 전기적인 신호로 변환해서 주고 받는 기능을 진행하는 계층입니다. 전송단위는 비트이며 케이블, 리피터, 허브 등의 장비를 이용합니다. (데이터의 종류나 에러 여부의 확인은 하지 않습니다)

##### 2) 데이터 링크 계층
물리적인 네트워크 사이에 데이터 전송을 담당하는 계층입니다. Mac주소를 통해 통신하며 CRC(Cyclic Redundancy Check) 기반의 오류 제어와 흐름 제어(CSMA/CD)를 합니다. 전송단위는 프레임이며 브리지, 스위치 등의 장비를 이용합니다.
> ##### CRC의 작동원리는?
>임의의 CRC 발생코드를 선정하고, 그 최고차수만큼 원본 데이터에 '0'을 붙입니다. 이를 다시 발생코드로 Mod-2에서 나눕니다. 나머지가 발생하면 이를 나머지를 붙이고 아니면 그대로 전송합니다. 수신측에서 발생코드로 수신 데이터를 나눴을 때 나머지가 발생하지 않으면 오류가 없다고 판정합니다.

##### 3) 네트워크 계층
다른 네트워크와 통신하기 위한 경로 설정을 위해 라우팅을 하고 흐름 제어, 오류 제어, 세그먼테이션 당당하는 계층입니다. 전송 단위는 패킷이며 라우터를 이용합니다.

##### 4) 전송 계층
목적지에 신뢰할 수 있는 데이터를 전달을 담당하는 계층입니다. 오류를 점검하고 전송 목적이가 어떤 애플리케이션인지 식별하는 기능도 있습니다. TCP 혹은 UDP 프로토콜을 이용하며, 각각 전송 단위는 세그멘트, 데이터그램입니다.

##### 5) 세션 계층
통신의 논리적 연결을 담당합니다. 양 끝단의 응용프로세스가 통신을 관리하기 위한 방법을 제공합니다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있으며 전송 단위는 데이터 또는 메세지입니다. 

##### 6) 표현 계층
데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당합니다. 코드간의 번역을 제공하여 상위 계층에서 데이터의 형식상의 차이를 다루는 부담을 덜어줍니다. JPEG, MPEF 등의 프로토콜이 있습니다.

##### 7) 응용 계층
다양하게 존재하는 응용 환경에서 공통적으로 필요한 기능을 다룹니다. 시스템 간의 응용 처리는 상호 간에 통신하면서 일련의 업무를 처리할 수 있도록 필요한 서비스 기능을 제공합니다. 이메일, 파일 전송, 웹 사이트 조회 등 어플리케이션에 대한 서비스를 제공하는 계층입니다. 사용자와 가장 밀접한 계층이며, 인터페이스 역활을 합니다. DNS, FTP, HTTP등의 프로토콜이 있습니다.

##### 참고자료

- https://velog.io/@gndan4/네트워크-입문

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 전이중 통신과 반이중 통신이 무엇입니까?

송수신이 동시에 이뤄지는 것이 전이중 통신, 번갈아가면서 통신하는 방식이 반이중 통신입니다. 반이중 통신 방식은 데이터를 동시에 전송하면 충돌이 발생합니다. 스위치가 전이중 통신을 하며, 허브의 경우는 반이중 통신을 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### ARP 캐시가 무엇입니까?

먼저 ARP란 목적지 IP주소를 통해 해당 컴퓨터의 MAC주소를 찾는데 사용되는 프로토콜입니다. 이러한 IP 대 하드웨어 주소 매핑 정보를 저장하는 공간이 ARP캐시입니다. IP는 가변적이기 때문에 일정 시간이 지나면 정보가 삭제됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## TCP와 UDP의 장단점을 설명해 주세요.

TCP는 연결형 통신 프로토콜에 사용되고 UDP는 비연결형 통신 프로토콜에 사용됩니다. TCP는 신뢰성/정확성에 목적을 두고, UDP는 효율성에 목적을 둔 통신방식입니다. TCP는 신뢰성을 확보할 수 있어 일반적으로 사용되지만 확인 작업을 거쳐야 하기에 속도면에서 손해가 있습니다. 이에 실시간 동영상 스트리밍 서비스 등에는 신뢰성은 떨어지지만 일단 보내고 보는 UDP가 사용됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 가상회선 패킷 교환과 데이터그램 패킷 교환은 무엇인가요?

가상회선 패킷 교환 방식은 연결 지향형입니다. 데이터를 전송하기 전에 논리적 연결을 설정하는데, 이를 가상회선이라고 합니다. 각 패킷에는 가상회선 식별 번호가 포함되고, 해당 회선으로 데이터를 전송합니다. 이에 반해, 데이터그램 패킷 교환 방식은 비연결 지향형입니다. 별도의 논리적 연결을 설정하지 않고, 패킷이 독립적으로 전송되며 이를 데이터그램이라고 합니다. 각 패킷은 라우터에서 최적의 경로를 별도로 지정해 주기에 가상회선 패킷 교환 방식과 상이하게 여러 패킷은 서로 다른 경로로 전송될 수도 있습니다. 속도 이외의 차이점에는 네트워크 내의 한 노드가 다운되면 데이터그램 방식은 다른 경로를 새로 설정하지만, 가상회선 방식은 그 노드를 지나는 모든 가상회선을 잃게 된다는 점이 있습니다.

##### 참고자료

- https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 3-way 핸드셰이크와 4-way 핸드셰이크를 설명해 주세요.

먼저 3-way 핸드셰이크는 TCP에 사용되는 방식으로 SYN(연결 요청), ACK(확인 응답)을 통해 연결을 확립하는 방법입니다. 클라이언트가 SYN패킷(x) 전송(000010) → 서버가 SYN(y) + ACK(x+1)패킷을 전송(010010) → 클라이언트가 ACK(y+1) 패킷을 전송(010000)의 순으로 논리적인 연결 확립을 위해 패킷 요청을 3번 교환하는 것을 3-way 핸드셰이크라고 합니다.<br>
반면 4-way 핸드셰이크는 연결을 종료할 때 사용되는 방식입니다. 클라이언트가 FIN 패킷 전송(000001) → 서버가 ACK 패킷 전송(010000) → 서버가 ACK 패킷을 모두 전송하면 FIN 패킷을 전송(000001) → 클라이언트는 FIN 패킷을 받고 ACK패킷을 전송(010000) → 서버는 ACK패킷을 받고 소켓을 닫는다 → 클라이언트도 TIME_WAIT 동안 기다리다가 소켓을 닫는다(수신 못한 데이터 대비)의 순으로 연결 종료를 위해 4번의 패킷 요청을 교환하는 것을 4-way 핸드셰이크라고 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 3-way Handshake에서 서버도 클라이언트의 ACK 패킷을 기다리는 이유는 무엇인가요?

TCP는 양방향 통신을 지원하기 때문에 클라이언트가 서버에 데이터를 요청한 경우 서버에서 클라이언트에 데이터를 보낼 때 연결된 상태가 필요하기 때문입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### SYN Flooding이 무엇이며 이를 방어하는 방법은 무엇입니까?

TCP 연결 방법인 3-way 핸드셰이크를 이용한 공격 방법입니다. 공격자가 다수의 SYN 패킷을 보내고 서버가 보낸 SYN + ACK 패킷에 응답하지 않아 서버의 메모리를 잡아먹어서 다운시키는 공격 방법입니다. 방어하는 방법으로는 가장 기본적으로는 동일한 IP에서 전송되는 SYN 패킷은 임계치를 설정해 drop시키는 방법이 있고, SYN Cookie를 이용하거나 SYN Proxy를 이용하는 방법이 있습니다. 먼저 SYN을 받으면 SYN Cookie를 포함한 SYN + ACK 패킷을 보내는 방법입니다. 일정 시간동안 SYN Cookie에 대한 정상적인 응답 패킷이 들어오지 않으면 방화벽에서 차단하고 정상적인 패킷이 들어오면 통신을 가능하게 해주는 방식입니다. SYN Proxy 또한 쿠키를 이용하여 정상적인 3-way 핸드셰이크인지 확인합니다. 정상적인 경우 방화벽에서 해당 연결을 서버에 재현시켜주는 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### TCP 연결이 수립되고 실제로 데이터를 보내는 방식을 설명하고 이를 효율적으로 하기 위해서 제안된 방식이 무엇인가요?

TCP는 일련 번호와 확인 응답 번호를 통해 데이터를 전송합니다. 클라이언가 서버로 일련 번호와 확인 응답 번호를 보내면 서버는 이를 확인하고 일련 번호에는 확인 응답 번호를, 확인 응답 번호에는 다음에 수신하고자 하는 데이터를 전송합니다. 이러한 일련의 과정이 전체 데이터가 전송되기까지 반복합니다. (Stop and Wait) 하지만 이런 식으로 세그먼트를 하나 보낼 때마다 확인 응답을 반환하는 방식은 효율이 높지 않기에 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 확인 응답을 반환합니다. (Sliding Window) 이 과정에서 수신 측은 쌓이는 세그먼트를 임시적으로 보관하는 버퍼가 필요합니다. 버퍼에는 한계 크기가 있으므로 3-way 핸드셰이크 시 윈도우 크기를 함께 보내서 윈도우 크기를 미리 확인해 놓는 작업으로 오버플로를 방지할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### TCP에서 흐름제어와 혼잡제어가 무엇입니까?

흐름제어는 수신 측보다 송신 측의 속도가 빠를 경우 발생하는 문제를 해결하기 위한 기법입니다. (1-8 참조) 혼잡제어는 송신하는 데이터가 라우터에 몰려 자신에게 온 데이터를 모두 처리할 수 없어 발생하는 문제를 해결하기 위한 기법입니다. 송신측에서 보내는 데이터의 전송속도를 강제적으로 줄여서 해결합니다. 사용되는 방식으로는 AIMD, Slow Start, Fast Retransmit, Fast Recovery 등이 있습니다.

- **AIMD** : 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 Window의 크기를 1씩 증가시키고, 전송에 실패하거나 일정시간이 넘으면 패킷을 보내는 속도를 절반으로 줄이는 방식입니다. 공평한 방식이지만 초기에 네트워크의 높은 대역폭을 사용하지 못해 오랜 시간이 걸리고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못합니다.

- **Slow Start** : 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 각 ACK 패킷마다 Window의 크기를 1씩 증가시키고, 혼잡 현상이 발생하면 Window의 크기를 1로 떨어뜨리는 방식입니다. 처음엔 네트워크 수용량을 예상할 수 없지만 한 번 혼잡 현상이 발생하고 나면 네트워크 수용량을 어느 정도 예상할 수 있기에 이후 부터는 혼잡이 발생했던 Window크기의 절반까진 지수 함수의 형태로 Window의 크기를 증가시키고 이후부터는 완만하게 1씩 증가시킵니다.

- **Fast Retransmit** : 패킷이 순서대로 전송되면 마지막으로 제대로 수신한 ACK 패킷을 보냅니다. 그러면 패킷이 중간에 손실된 경우는 특정 ACK패킷이 중복으로 수신되게 되므로 이를 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있습니다. 이러한 중복 순번 패킷을 3개 받으면 재전송을 해주고, 이 또한 혼잡 상태로 간주할 수 있으므로 Window의 크기를 줄입니다.

- **Fast Recovery** : 혼잡 상태가 되면 Window의 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법입니다. 해당 정책을 적용하면 혼잡 상태를 겪은 후부터 AIMD 방식으로 작동됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## TCP/IP(Transmission Control Protocol / Internet Protocol) 모델이 무엇입니까?

OST 모델을 4계층으로 단순화 시켜서 사용하는 모델입니다. 응용 계층, 전송 계층, 인터넷 계층, 네트워크 접속 계층으로 나뉩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## HTTP와 HTTPS는 무엇인가요?

먼저 HTTP는 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜입니다. TCP와 UDP를 사용합니다. HTTP는 평문 통신이 되기에 도청이 가능하고, 통신 상대를 확인하지 않아 위장이 가능합니다. 또한 완전성을 증명할 수 없기에 변조가 가능합니다. 이러한 문제점을 보완하기 위해 제시된 것이 HTTPS입니다. HTTP에 SSL 프로토콜을 같이 사용해 암호화와 인증, 완전성 보호를 더했습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP의 GET과 POST에 대해 설명해 주세요.

둘 모두 서버에 무엇인가를 요청할 때 사용하는 방식입니다. GET은 요청한 데이터가 HTTP Request Message의 헤더 부분에 url이 담겨서 전송됩니다.따라서 데이터가 url상에 붙어서 request가 보내집니다. 전송할 수 있는 크기가 제한적이고, 보안이 필요한 데이터도 그대로 url에 노출됩니다. POST는 요청한 데이터가 HTTP Request Message의 바디 부분에 담겨서 전송됩니다. GET 방식에 비해 보낼 수 있는 데이터 크기가 크고 보안면에서 낫습니다. 용도는 GET은 데이터를 가져오는 것에 있고, POST는 값이나 상태를 바꾸는 것 즉, 수행하는 것에 있습니다.

##### 참고자료

- http://tcpschool.com/jquery/jq_ajax_httpRequest

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 조회에 POST보다 GET이 사용되는 이유는 무엇인가요?

GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답을 주는 것이 가능하고 캐싱을 이용할 수 있어 속도 면에서 빠릅니다. 또한 웹에서 모든 리소스는 링크할 수 있는 url을 가지고 있어야 합니다. 그런 측면에서 POST 방식을 사용할 경우에 값이 Body에 있기 때문에 url만 전달할 수 없습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP Method에서 PUT과 PATCH의 차이점을 설명해 주세요.

put -> 모두 교체<br>
patch -> 일정부분<br>

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 단방향 암호화와 양방향 암호화는 무엇인가요?

단방향 암호화 -> 암호화 ㅇ 복호화 ㄴ<br>
양방향 암호화 -> 암호화 ㅇ 복호화 ㅇ<br>

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 대칭키와 공개키는 무엇입니까?

대칭키는 암호화 키와 복호화 키가 같은 알고리즘입니다. SHA나 MD5등이 있으며, 암호화 키는 공개되지 않고 이를 알고 있는 자만 문서를 해독할 수 있습니다. 속도는 빠르지만 키 교환의 문제나 향후 키의 수가 증가할 경우 키를 관리하기 어려운 문제를 가지고 있습니다. 반면 공개키는 암호화 키와 복호화 키가 상이합니다. 암호화 키를 공개하며 개인이 가지고 있는 복호화 키로 해독이 가능합니다. 대표적으론 RSA알고리즘이 있으며, 대칭키에 비해 속도가 느리지만 비밀키를 복호화하는 것이 불가능하기에 보안유지가 용이합니다. SSL에 사용되는 방식 또한 공개키 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 쿠키와 세션이 무엇이며, 필요한 이유가 무엇인가요?

먼저 2개 모두 HTTP 프로토콜이 가지는 비연결 지향, 상태정보 유지 안 함의 2가지 특징 때문에 제안된 개념입니다. HTTP 프로토콜에서 상태를 유지하기 위한 기술입니다. 먼저 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일입니다. 클라이언트의 상태 정보를 브라우저에 저장하여 참조합니다. 사용자 정보나 쇼핑몰 장바구니 등에 사용됩니다. 세션은 일정 시간 동안 같은 브라우저로부터 오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술입니다. 용도는 로그인 등에 사용됩니다. 세션 또한 쿠키를 수단으로 상태 정보를 유지하지만 여러 가지 차이점이 존재합니다. 먼저 쿠키는 클라이언트에, 세션은 서버에 정보를 저장하고, 보안상 세션이 더 유리한 점이 있습니다. 하지만 쿠키는 브라우저를 종료해도 남아있지만 세션은 브라우저 종료 시 삭제됩니다. 속도면 또한 쿠키는 빠르지만 세션의 경우 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요하고 따라서 쿠키보다는 느린 점을 보입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 소켓 프로그래밍이란 무엇인가요?

먼저 소켓은 프로그램이 네트워크에서 데이터를 송수신할 수 있도록 네트워크 환경에 만들어진 연결부입니다. 이를 이용한 통신 프로그래밍을 소켓 프로그래밍이라고 합니다.

##### 참고자료

- https://recipes4dev.tistory.com/153
- https://velog.io/@devsh/네트워크-기초-개념-정리하기-소켓과-소켓-프로그래밍-개념

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 클라이언트 소켓과 서버 소켓이 무엇인가요?

두 개의 시스템 혹은 프로세스가 소켓을 통해 네트워크 연결을 만들기 위해서는, 최초에 클라이언트 측에서 서버 측으로 연결을 요청해야 합니다. IP 주소와 포트번호로 서버를 식별하였을 때 해당 요청을 처리할 수 있을 때 요청을 받아들입니다. 이 때, 연결 요청을 보내는 소켓을 클라이언트 소켓, 요청을 받아들이는 소켓을 서버 소켓이라고 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 소켓 API의 실행 흐름에 대해서 설명해 주세요.

클라이언트 소켓은 처음 소켓을 생성하고 연결을 요청합니다. 연결이 받아들여지면 데이터를 송수신하고 모든 처리가 완료되면 소켓을 닫습니다. 서버 소켓의 경우 소켓을 생성하고 서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 결합시킵니다. 이후 연결 요청이 수신되는지 주시하다가 요청이 수신되면 이를 받아들입니다. 이후 데이터를 송수신하고 모든 처리가 완료되면 소켓을 닫습니다.

![소켓 API 실행 흐름도](./img/소켓%20API%20실행%20흐름도.png)

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP 통신과 소켓 통신의 장단점을 설명해 주세요.

HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단반향 통신입니다. 서버로부터 응답을 받은 후에는 연결이 바로 종료됩니다. 반면 소켓 통신은 특정 포트로 연결을 성립하고 있기 때문에 실시간으로 양방향 통신을 할 수 있습니다. 따라서 필요에 따라 서버 또한 클라이언트로 요청을 보낼 수 있습니다. 이러한 특성 때문에 HTTP 통신은 불필요한 자원의 점유를 없애 비용 및 유지보수 등이 좋습니다. 다만, 실시간 통신에는 많은 부하가 걸립니다. 반면, 소켓 통신은 접속을 계속 유지하기에 실시간으로 데이터를 주고 받는 게임이나 채팅 등의 서비스를 제공하기 용이하지만 서버의 자원에 따라 연결할 수 있는 클라이언트의 수가 제한됩니다.

##### 참고자료

- https://mangkyu.tistory.com/48
- https://wiper2019.tistory.com/185

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 웹 브라우저에 URL을 입력하면 일어나는 시나리오에 대해 설명해 주세요.

![웹의 동작 원리](./img/웹의%20동작%20원리.png)

①, ② : 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력함.<br>
③ : 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색함.<br>
④ : DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함.<br>
⑤, ⑥ : 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성함.<br>
이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨.<br>
⑦ : 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환됨.<br>
⑧ : 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색함.<br>
⑨, ⑩ : 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성함.<br>
이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨.<br>
⑪ : 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨.<br>
⑫ : 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨.<br>

간략히 요약하면 사용자가 URL입력 시 브라우저는 이를 DNS서버에 요청하여 해당하는 IP주소를 전달받고, 이를 토대로 서버와 연결을 구축 후 서버에서 보내주는 데이터를 브라우저 상에 띄우게 됩니다. 최근에는 클라이언트와 서버 사이에 프록시 서버가 추가되어 운용됩니다.

##### 참고자료

- http://tcpschool.com/webbasic/works
- https://owlgwang.tistory.com/1

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### DNS 동작 방식을 설명해 주세요.

![DNS 동작 방식](./img/DNS%20동작%20방식.png)

1. 브라우저에 www.example.com을 입력
- **캐시 DNS의 www.example.com 캐시가 있을 때**<br>
    2. 클라이언트가 www.example.com으로 요청 시, 클라이언트의 Resolver에 등록된 캐시 네임서버(DNS resolver)로 질의.<br>
    7. 캐시 DNS(Resolver 네임서버)가 www.example.com에 대한 캐시가 있을 경우, 클라이언트에게 응답하여 종료<br>
- **캐시 DNS의 www.example.com 캐시가 없을 때**<br>
    2. 클라이언트가 www.example.com으로 요청 시, Client의 Resolver에 등록된 캐시 네임서버(DNS resolver)로 질의.<br>
    3. 캐시 DNS(Resolver 네임서버)가 www.example.com에 대한 캐시가 없을 경우, root 네임서버로 .com 네임서버 질의하여 .com(TLD) 네임서버 주소를 받음.<br>
    4. .com 네임서버에게 example.com 네임서버 주소 질의하여 example.com 네임서버 주소 받음<br>
    5. example.com 네임서버에게 www.example.com에 대한 주소를 질의<br>
    6. www.example.com 네임서버가 자신의 www에 대한 A Record를 확인 후, IP 주소를 응답.<br>
    7. 캐시 DNS서버(Resolver)는 응답 받은 IP주소를 Client에게 전송.<br>
8. Client는 응답받은 IP주소를 이용하여 www.example.com 서버로 요청<br>
9. 8번 과정에 대한 프로토콜별 응답.<br>

##### 참고자료

- https://devopsnet.tistory.com/40

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 프록시 서버란 무엇인가요?

프록시 서버란 클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 중간에서 연결을 대리해주는 서버입니다. 사용되는 이유에는 크게 캐시 데이터 사용, 보안성, 접속 우회 등 3가지가 있습니다. 먼저, 프록시 서버에 요청된 내용 중 일부를 웹 캐시에 저장해 준다면, 클라이언트가 동일한 요청을 보낼 시 프록시에서 바로 해당 데이터를 줄 수 있습니다. 이는 서버 운용 속도도 높일 뿐더러, 서버에 들어가는 트래픽을 줄여서 서버 부하도 줄여줍니다. 프록시 사용 시 보안성을 위해 프록시 자체를 방화벽으로 사용할 수 도 있고, 클라이언트의 IP를 숨길 수도 있습니다. 마찬가지로 접속 우회의 경우, IP를 위장할 수 있기에 서버에서 다른 클라이언트로 접속한 것처럼 속일 수 있기에 접속 제한을 우회할 수 있습니다.

##### 참고자료

- https://liveyourit.tistory.com/251

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 네트워크 바이트 오더가 무엇입니까?

바이트 오더란 시스템 내부적으로 데이터를 저장하는 순서입니다. 그 중에서 네트워크 상에 데이터를 전송할 때 택하는 바이트 오더를 네트워크 바이트 오더라고 합니다. 바이트 오더는 크게 빅 엔디안과 리틀 엔디안이 있는데, 네트워크 바이트 오더에선 빅 엔디안을 흔히 사용합니다. 이에 반해 흔히 사용하는 CPU, 인텔 CPU에선 리틀 엔디안을 사용하기에 네트워크 통신 시 리틀 엔디안을 빅 엔디안으로, 혹은 빅 엔디안을 리틀 엔디안으로 변환해주는 작업이 필수적으로 이뤄져야 합니다. 소켓 통신 시 자주 사용되는 write나 read 함수는 이미 내부적으로 엔디안 처리가 구현되어 있습니다.

##### 참고자료

- https://jhnyang.tistory.com/226

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 빅 엔디안과 리틀 엔디안이 무엇이고, 각각의 장단점은 무엇입니까?

![리틀 엔디안과 빅 엔디안](./img/리틀%20엔디안과%20빅%20엔디안.png)

최상위 바이트가 앞에 오는 것이 빅 엔디안, 최하위 바이트가 앞에 오는 경우 리틀 엔디안이라고 합니다. 리틀 엔디안의 경우, 수학적 연산이 쉽고, 단위가 커질 경우 해당 연산처리가 빠릅니다. 반면, 빅 엔디안의 경우 비교 연산이 쉽고, 디버깅 과정에서 메모리 값을 보는 것이 편합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 로드 밸런싱이 무엇인가요?

늘어나는 트래픽을 감당하기 위해 제안된 방법으로 서버 하드웨어의 성능을 올리는 스케일 업과 여러 대의 서버가 나눠서 일하는 스케일 아웃이 있습니다. 하드웨어 향상은 비용 면에서도 비싸고, 서버가 여러 대면 무중단 서비스를 제공하는 환경 구성이 용이하기에 스케일 아웃이 자주 사용됩니다. 여기서 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 로드 밸런싱입니다. 로드 밸런서를 클라이언트와 서버 사이에 두고 부하(Load)가 일어나지 않도록 여러 서버에 분산시켜주는 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 로드 밸런서가 서버를 선택하는 방식을 설명해 주세요.

흔히 CPU스케줄링의 라운드 로빈 방식을 활용하거나 최소 연결 방식, IP 해시 방식이 있습니다. 라운드 로빈 방식은 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식입니다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합합니다. 서버가 스펙의 차이를 가지고 있다면 이를 개선한 가중 라운드 로빈 방식이 있습니다. IP 해시 방식은 IP주소를 특정 서버로 매핑하여 요청을 처리하는 방식입니다. 사용자가 항상 동일한 서버로 연결되는 것을 보장합니다. 최소 연결 방식은 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 우선적으로 트래픽을 배분하는 방식입니다. 세션이 자주 길어지거나, 서버에 분배된 트래픽이 일정하지 않은 경우 적합한 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### L4 로드 밸런서와 L7 로드 밸런서에 대해 설명해 주세요.

가장 많이 활용되는 로드 밸런서입니다. OSI 7계층에 따라서 나뉘어진 장비입니다. L4 로드 밸런서는 TCP/UDP의 포트 정보를 바탕으로 서버에 분배하고 L7 로드 밸런서는 TCP/UDP 정보 뿐 아니라 HTTP의 URI, FTP의 파일 명 등의 정보를 바탕으로 로드를 분산합니다. L4 로드 밸런서는 속도가 빠르고 복호화 필요가 없기에 안전하고 값이 저렴합니다. 하지만 섬세한 라우팅이 불가능하고 사용자 IP가 수시로 바뀌는 경우에는 연속적인 서비스를 제공하기 어렵습니다. 반면 L7 로드 밸런서는 섬세한 라우팅이 가능하고 비정상적인 트래픽을 사전에 필터링 할 수 있어 서비스 안정성이 높지만, 복호화에 높은 비용을 지불해야하고 클라이언트가 로드 밸런서와 인증서를 공유해야하기 때문에 공격자가 로드 밸런서를 통해서 클라이언트 데이터에 접근할 수 있는 보안상 위험성이 존재합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## REST(REpresentational State Transfer)란 무엇인가요?

네트워크 상에서 Client와 Server사이의 통신 방식 중 하나입니다. 정확히는 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다. REST에는 6가지 규칙이 있으며 Uniform Interface(유니폼 인터페이스), Stateless(무상태성), Cacheable(캐싱 가능), Self-descriptiveness(자체 표현 구조), Client-Server 구조, Layered System(계층형 구조)이 그것입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### RESTful API란 무엇인가요?

REST의 기본원칙을 성실히 지켜 API를 디자인 하는 것입니다. REST의 가장 중심된 규칙은 URI는 정보의 자원을 표현해야 한다는 것과 자원에 대한 행위는 HTTP Method로 표현해야 한다는 점입니다. 이 원칙 아래 간단히 리소스와 행위를 명시적이고 직관적으로 분리해야 하며, Message는 헤더와 바디를 명확하게 분리해서 사용해야 합니다. API 버전을 관리하고 서버와 클라이언트가 같은 방식을 사용해서 요청하도 하는 것 등이 RESTful하게 API를 디자인하는 것이라고 할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## ETC

<details>
 <summary><strong>한정적인 시간 가운데 선택적으로 공부하지 않은 내용입니다.</strong></summary>
 <div markdown = "1">

>시간적 여유가 있을 때 보충예정

- [네트워크 계층 - IP 관련](#https://velog.io/@gndan4/네트워크-네트워크-계층)
- [클라이언트가 url로 서버를 요청했을 때 상세 과정](https://owlgwang.tistory.com/1)
- 3-way Handshake 보충
- HTTP Method에서 PUT과 PATCH의 차이점(예시)
- 단방향 암호화와 양방향 암호화
- REST의 자원의 표현 (Json, XML 차이점)

</div>
</details>