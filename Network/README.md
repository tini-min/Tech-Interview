# Network

<details>
 <summary><strong>용어 정리 (기초용어)</strong></summary>
 <div markdown = "1">

- **프로토콜** : 컴퓨터 간에 정보를 주고 받을 때의 통신 방법에 대한 규칙이나 표준입니다.

</div>
</details>

<details>
 <summary><strong>목차</strong></summary>
 <div markdown = "1">

- [OSI 7계층이 무엇이고 이를 나누는 이유가 무엇입니까?](#osi-7계층이-무엇이고-이를-나누는-이유가-무엇입니까)
    * [OSI 7계층의 각 계층을 설명해 주세요.](#osi-7계층의-각-계층을-설명해-주세요)
    * [전이중 통신과 반이중 통신이 무엇입니까?](#전이중-통신과-반이중-통신이-무엇입니까)
    * [ARP가 무엇입니까?](#arp가-무엇입니까)
- [TCP와 UDP의 장단점을 설명해 주세요.](#tcp와-udp의-장단점을-설명해-주세요)
    * [DNS나 실시간 스트리밍은 신뢰성이 필요없나요?](#dns나-실시간-스트리밍은-신뢰성이-필요없나요)
    * [가상회선 패킷 교환과 데이터그램 패킷 교환은 무엇인가요?](#가상회선-패킷-교환과-데이터그램-패킷-교환은-무엇인가요)
    * [3-way 핸드셰이크와 4-way 핸드셰이크를 설명해 주세요.](#3-way-핸드셰이크와-4-way-핸드셰이크를-설명해-주세요)
        + [3-way Handshake에서 서버도 클라이언트의 ACK 패킷을 기다리는 이유는 무엇인가요?](#3-way-handshake에서-서버도-클라이언트의-ack-패킷을-기다리는-이유는-무엇인가요)
    * [SYN Flooding이 무엇이며 이를 방어하는 방법은 무엇입니까?](#syn-flooding이-무엇이며-이를-방어하는-방법은-무엇입니까)
    * [TCP 연결이 수립되고 실제로 데이터를 보내는 방식을 설명하고 이를 효율적으로 하기 위해서 제안된 방식이 무엇인가요?](#tcp-연결이-수립되고-실제로-데이터를-보내는-방식을-설명하고-이를-효율적으로-하기-위해서-제안된-방식이-무엇인가요)
    * [TCP에서 흐름제어와 혼잡제어가 무엇입니까?](#tcp에서-흐름제어와-혼잡제어가-무엇입니까)
- [TCP/IP(Transmission Control Protocol / Internet Protocol) 모델이 무엇입니까?](#tcpiptransmission-control-protocol--internet-protocol-모델이-무엇입니까)
- [HTTP와 HTTPS는 무엇인가요?](#http와-https는-무엇인가요)
    * [SSL의 동작 방식을 설명해 주세요.](#ssl의-동작-방식을-설명해-주세요)
    * [단방향 암호화와 양방향 암호화는 무엇인가요?](#단방향-암호화와-양방향-암호화는-무엇인가요)
        + [대칭키와 공개키는 무엇입니까?](#대칭키와-공개키는-무엇입니까)
        + [암호화 키를 비공개하고 복호화 키를 공개하는 경우에 대해 설명해 주세요.](#암호화-키를-비공개하고-복호화-키를-공개하는-경우에-대해-설명해-주세요)
    * [HTTP의 GET과 POST에 대해 설명해 주세요.](#http의-get과-post에-대해-설명해-주세요)
    * [조회에 POST보다 GET이 사용되는 이유는 무엇인가요?](#조회에-post보다-get이-사용되는-이유는-무엇인가요)
    * [HTTP Method에서 POST과 PATCH의 차이점을 설명해 주세요.](#http-method에서-post과-patch의-차이점을-설명해-주세요)
    * [쿠키와 세션이 무엇이며, 필요한 이유가 무엇인가요?](#쿠키와-세션이-무엇이며-필요한-이유가-무엇인가요)
- [소켓 프로그래밍이란 무엇인가요?](#소켓-프로그래밍이란-무엇인가요)
    * [클라이언트 소켓과 서버 소켓이 무엇인가요?](#클라이언트-소켓과-서버-소켓이-무엇인가요)
    * [소켓 API의 실행 흐름에 대해서 설명해 주세요.](#소켓-api의-실행-흐름에-대해서-설명해-주세요)
    * [HTTP 통신과 소켓 통신의 장단점을 설명해 주세요.](#http-통신과-소켓-통신의-장단점을-설명해-주세요)
- [웹 브라우저에 URL을 입력하면 일어나는 시나리오에 대해 설명해 주세요.](#웹-브라우저에-url을-입력하면-일어나는-시나리오에-대해-설명해-주세요)
    * [DNS 동작 방식을 설명해 주세요.](#dns-동작-방식을-설명해-주세요)
    * [프록시 서버란 무엇인가요?](#프록시-서버란-무엇인가요)
- [웹 서버와 웹 애플리케이션 서버란 무엇인가요?](#웹-서버와-웹-애플리케이션-서버란-무엇인가요)
- [네트워크 바이트 오더가 무엇입니까?](#네트워크-바이트-오더가-무엇입니까)
    * [빅엔디안과 리틀엔디안이 무엇이고, 각각의 장단점은 무엇입니까?](#빅엔디안과-리틀엔디안이-무엇이고-각각의-장단점은-무엇입니까)
- [로드 밸런싱이 무엇인가요?](#로드-밸런싱이-무엇인가요)
    * [로드 밸런서가 서버를 선택하는 방식을 설명해 주세요.](#로드-밸런서가-서버를-선택하는-방식을-설명해-주세요)
    * [L4 로드 밸런서와 L7 로드 밸런서에 대해 설명해 주세요.](#l4-로드-밸런서와-l7-로드-밸런서에-대해-설명해-주세요)
- [REST(REpresentational State Transfer)란 무엇인가요?](#restrepresentational-state-transfer란-무엇인가요)
    * [REST의 특징을 설명해 주세요.](#rest의-특징을-설명해-주세요)
    * [RESTful API란 무엇인가요?](#restful-api-무엇인가요)

</div>
</details>

## OSI 7계층이 무엇이고 이를 나누는 이유가 무엇입니까?

OSI7계층은 국제표준화기구에서 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것입니다. 통신이 일어나는 과정을 단계별로 이해하기 쉽고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기에 사용합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### OSI 7계층의 각 계층을 설명해 주세요.

각 계층은 하위 단계부터 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층 순으로 존재합니다. 일반적으로 물리부터 전송 계층은 하드웨어로, 그 위의 상위 계층은 소프트웨어로 구현됩니다.

##### 1) 물리 계층
데이터를 전기적인 신호로 변환해서 주고 받는 기능을 진행하는 계층입니다. 전송단위는 비트이며 케이블, 리피터, 허브 등의 장비를 이용합니다. (데이터의 종류나 에러 여부의 확인은 하지 않습니다)

##### 2) 데이터 링크 계층
물리적인 네트워크 사이에 데이터 전송을 담당하는 계층입니다. Mac주소를 통해 통신하며 CRC(Cyclic Redundancy Check) 기반의 오류 제어와 흐름 제어(CSMA/CD)를 합니다. 전송단위는 프레임이며 브리지, 스위치 등의 장비를 이용합니다.
> ##### CRC의 작동원리는?
>임의의 CRC 발생코드를 선정하고, 그 최고차수만큼 원본 데이터에 '0'을 붙입니다. 이를 다시 발생코드로 Mod-2에서 나눕니다. 나머지가 발생하면 이를 나머지를 붙이고 아니면 그대로 전송합니다. 수신측에서 발생코드로 수신 데이터를 나눴을 때 나머지가 발생하지 않으면 오류가 없다고 판정합니다.

##### 3) 네트워크 계층
다른 네트워크와 통신하기 위한 경로 설정을 위해 라우팅을 하고 흐름 제어, 오류 제어, 세그먼테이션 당당하는 계층입니다. 전송 단위는 패킷이며 라우터를 이용합니다.

##### 4) 전송 계층
목적지에 신뢰할 수 있는 데이터를 전달을 담당하는 계층입니다. 오류를 점검하고 전송 목적지가 어떤 애플리케이션인지 식별하는 기능도 있습니다. TCP 혹은 UDP 프로토콜을 이용하며, 각각 전송 단위는 세그멘트, 데이터그램입니다.

##### 5) 세션 계층
통신의 논리적 연결을 담당합니다. 양 끝단의 응용프로세스가 통신을 관리하기 위한 방법을 제공합니다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있으며 전송 단위는 데이터 또는 메세지입니다. 

##### 6) 표현 계층
데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당합니다. 코드간의 번역을 제공하여 상위 계층에서 데이터의 형식상의 차이를 다루는 부담을 덜어줍니다. JPEG, MPEF 등의 프로토콜이 있습니다.

##### 7) 응용 계층
다양하게 존재하는 응용 환경에서 공통적으로 필요한 기능을 다룹니다. 시스템 간의 응용 처리는 상호 간에 통신하면서 일련의 업무를 처리할 수 있도록 필요한 서비스 기능을 제공합니다. 이메일, 파일 전송, 웹 사이트 조회 등 어플리케이션에 대한 서비스를 제공하는 계층입니다. 사용자와 가장 밀접한 계층이며, 인터페이스 역활을 합니다. DNS, FTP, HTTP등의 프로토콜이 있습니다.

##### 참고자료

- https://velog.io/@gndan4/네트워크-입문

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 전이중 통신과 반이중 통신이 무엇입니까?

송수신이 동시에 이뤄지는 것이 전이중 통신, 번갈아가면서 통신하는 방식이 반이중 통신입니다. 반이중 통신 방식은 데이터를 동시에 전송하면 충돌이 발생합니다. 스위치가 전이중 통신을 하며, 허브의 경우는 반이중 통신을 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### ARP가 무엇입니까?

ARP는 주소 변환 프로토콜로 네트워크 계층과 데이터 링크 계층 사이에서 주소 변환을 담당하는 프로토콜입니다. 목적지의 IP 주소를 이용해 MAC 주소를 찾는 데에 사용됩니다. 클라이언트는 MAC 주소를 얻은 후에 IP와 MAC의 매핑 정보(ARP 테이블)를 메모리에 보관합니다. 다만, IP 주소는 가변적이기에 테이블에서 보존 기간을 ARP 캐시로 지정하여 일정 시간이 지나면 삭제하고 새로 갱신합니다.

##### 참고자료

- https://velog.io/@gndan4/네트워크-데이터-링크-계층

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## TCP와 UDP의 장단점을 설명해 주세요.

TCP는 연결형 통신 프로토콜에 사용되고 UDP는 비연결형 통신 프로토콜에 사용됩니다. TCP는 신뢰성/정확성에 목적을 두고, UDP는 효율성에 목적을 둔 통신방식입니다. TCP는 신뢰성을 확보할 수 있어 일반적으로 사용되지만 확인 작업을 거쳐야 하기에 속도면에서 손해가 있습니다. 이에 실시간 동영상 스트리밍 서비스 등에는 신뢰성은 떨어지지만 일단 보내고 보는 UDP가 사용됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### DNS나 실시간 스트리밍은 신뢰성이 필요없나요?

실시간 스트리밍의 경우 잠깐 끊기다하여(데이터가 제대로 수신되지 않는다하여) 사용자가 큰 불편을 느끼지 않습니다. 하지만 반대로 TCP의 경우 1번부터 8번 데이터를 전송할 때, 1,2,4,5,6의 데이터가 도착했다면 일단 7번 전송을 요청하는 것이 아니라 3번 데이터 재전송을 요청합니다. 3번 데이터를 재수신하고 다시 7번 데이터를 수신하기에는 데이터 처리가 상당히 지연되게 됩니다. 따라서, 데이터의 빠른 전송이 요구될 때 UDP가 사용됩니다.<br>
DNS의 경우도 비슷하게, 간단한 도메인 네임을 넘겨서 네트워크 주소를 받는 작업에서 연결을 시작하고, 종료하는 작업의 비용이 일정 시간 DNS로부터 반응이 없을 때 다시 요청을 보내는 비용보다 더 크기 때문에 신뢰성에 크게 구애하지 않고 UDP를 이용합니다.

##### 참고자료

- https://hwanine.github.io/network/UDP/
- https://velog.io/@syi9595/UDP-가-DNS를-이용하는-이유

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**
### 가상회선 패킷 교환과 데이터그램 패킷 교환은 무엇인가요?

가상회선 패킷 교환 방식은 연결 지향형입니다. 데이터를 전송하기 전에 논리적 연결을 설정하는데, 이를 가상회선이라고 합니다. 각 패킷에는 가상회선 식별 번호가 포함되고, 해당 회선으로 데이터를 전송합니다. 이에 반해, 데이터그램 패킷 교환 방식은 비연결 지향형입니다. 별도의 논리적 연결을 설정하지 않고, 패킷이 독립적으로 전송되며 이를 데이터그램이라고 합니다. 각 패킷은 라우터에서 최적의 경로를 별도로 지정해 주기에 가상회선 패킷 교환 방식과 상이하게 여러 패킷은 서로 다른 경로로 전송될 수도 있습니다. 속도 이외의 차이점에는 네트워크 내의 한 노드가 다운되면 데이터그램 방식은 다른 경로를 새로 설정하지만, 가상회선 방식은 그 노드를 지나는 모든 가상회선을 잃게 된다는 점이 있습니다.

##### 참고자료

- https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 3-way 핸드셰이크와 4-way 핸드셰이크를 설명해 주세요.

`3-way 핸드셰이크`는 TCP에 사용되는 방식으로 SYN(연결 요청), ACK(확인 응답)을 통해 연결을 확립하는 방법입니다. 논리적인 연결 확립을 위해 패킷 요청을 3번 교환하는 것을 3-way 핸드셰이크라고 합니다.

![3-way Handshaking](./img/3-way%20Handshaking.png)

1. 클라이언트가 SYN패킷(x) 전송(000010)
2. 서버가 SYN(y) + ACK(x+1)패킷을 전송(010010)
3. 클라이언트가 ACK(y+1) 패킷을 전송(010000)

`4-way 핸드셰이크`는 연결을 종료할 때 사용되는 방식입니다. 연결 종료를 위해 4번의 패킷 요청을 교환하는 것을 4-way 핸드셰이크라고 합니다.

![4-way Handshaking](./img/4-way%20Handshaking.png)

1. 클라이언트가 FIN 패킷 전송(000001)
2. 서버가 (FIN에 대한) ACK 패킷 전송(010000)
3. 서버가 (수신된 데이터에 대한) ACK 패킷을 모두 전송하면 FIN 패킷을 전송(000001)
4. 클라이언트는 FIN 패킷을 받고 ACK패킷을 전송(010000)

> 서버는 ACK패킷을 받고 소켓을 닫습니다. <br>
> 클라이언트도 TIME_WAIT 동안 기다리다가 소켓을 닫습니다(수신 못한 데이터 대비)

##### 참고자료

- https://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 3-way Handshake에서 서버도 클라이언트의 ACK 패킷을 기다리는 이유는 무엇인가요?

TCP는 양방향 통신을 지원하기 때문에 클라이언트가 서버에 데이터를 요청한 경우 서버에서 클라이언트에 데이터를 보낼 때 연결된 상태가 필요하기 때문입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### SYN Flooding이 무엇이며 이를 방어하는 방법은 무엇입니까?

TCP 연결 방법인 3-way 핸드셰이크를 이용한 공격 방법입니다. 공격자가 다수의 SYN 패킷을 보내고 서버가 보낸 SYN + ACK 패킷에 응답하지 않아 서버의 메모리를 잡아먹어서 다운시키는 공격 방법입니다.<br>
방어 방법으로는 가장 기본적으로는 동일한 IP에서 전송되는 SYN 패킷은 임계치를 설정해 drop시키는 방법이 있고, SYN Cookie를 이용하거나 SYN Proxy를 이용하는 방법이 있습니다. 먼저 SYN을 받으면 SYN Cookie를 포함한 SYN + ACK 패킷을 보내는 방법입니다. 일정 시간동안 SYN Cookie에 대한 정상적인 응답 패킷이 들어오지 않으면 방화벽에서 차단하고 정상적인 패킷이 들어오면 통신을 가능하게 해주는 방식입니다. SYN Proxy 또한 쿠키를 이용하여 정상적인 3-way 핸드셰이크인지 확인합니다. 정상적인 경우 방화벽에서 해당 연결을 서버에 재현시켜주는 방식입니다.

|**SYN Cookie**|**SYN Proxy**|
|:---:|:--:|
|![SYN Cookie](./img/SYN%20Cookie.png)|![SYN Proxy](./img/SYN%20Proxy.png)|

##### 참고자료

- https://sata.kr/entry/DOSDDOS-SYN-Flooding-공격에-대해서-알아보자

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### TCP 연결이 수립되고 실제로 데이터를 보내는 방식을 설명하고 이를 효율적으로 하기 위해서 제안된 방식이 무엇인가요?

TCP는 일련 번호와 확인 응답 번호를 통해 데이터를 전송합니다. 클라이언가 서버로 일련 번호와 확인 응답 번호를 보내면 서버는 이를 확인하고 일련 번호에는 확인 응답 번호를, 확인 응답 번호에는 다음에 수신하고자 하는 데이터를 전송합니다. 이러한 일련의 과정이 전체 데이터가 전송되기까지 반복합니다. (Stop and Wait) 하지만 이런 식으로 세그먼트를 하나 보낼 때마다 확인 응답을 반환하는 방식은 효율이 높지 않기에 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 확인 응답을 반환합니다. (Sliding Window) 이 과정에서 수신 측은 쌓이는 세그먼트를 임시적으로 보관하는 버퍼가 필요합니다. 버퍼에는 한계 크기가 있으므로 3-way 핸드셰이크 시 윈도우 크기를 함께 보내서 윈도우 크기를 미리 확인해 놓는 작업으로 오버플로를 방지할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### TCP에서 흐름제어와 혼잡제어가 무엇입니까?

흐름제어는 수신 측보다 송신 측의 속도가 빠를 경우 발생하는 문제를 해결하기 위한 기법입니다. [흐름제어 관련 문서](#tcp-연결이-수립되고-실제로-데이터를-보내는-방식을-설명하고-이를-효율적으로-하기-위해서-제안된-방식이-무엇인가요)를 확인해 주세요. 혼잡제어는 송신하는 데이터가 라우터에 몰려 자신에게 온 데이터를 모두 처리할 수 없어 발생하는 문제를 해결하기 위한 기법입니다. 송신측에서 보내는 데이터의 전송속도를 강제적으로 줄여서 해결합니다. 사용되는 방식으로는 AIMD, Slow Start, Fast Retransmit, Fast Recovery 등이 있습니다.

![TCP 혼잡제어](./img/TCP%20혼잡제어.png)

- **AIMD** : 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 Window의 크기를 1씩 증가시키고, 전송에 실패하거나 일정시간이 넘으면 패킷을 보내는 속도를 절반으로 줄이는 방식입니다. 공평한 방식이지만 초기에 네트워크의 높은 대역폭을 사용하지 못해 오랜 시간이 걸리고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못합니다.

- **Slow Start** : 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 각 ACK 패킷마다 Window의 크기를 1씩 증가시키고, 혼잡 현상이 발생하면 Window의 크기를 1로 떨어뜨리는 방식입니다. 처음엔 네트워크 수용량을 예상할 수 없지만 한 번 혼잡 현상이 발생하고 나면 네트워크 수용량을 어느 정도 예상할 수 있기에 이후 부터는 혼잡이 발생했던 Window크기의 절반까진 지수 함수의 형태로 Window의 크기를 증가시키고 이후부터는 완만하게 1씩 증가시킵니다.

- **Fast Retransmit** : 패킷이 순서대로 전송되면 마지막으로 제대로 수신한 ACK 패킷을 보냅니다. 그러면 패킷이 중간에 손실된 경우는 특정 ACK패킷이 중복으로 수신되게 되므로 이를 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있습니다. 이러한 중복 순번 패킷을 3개 받으면 재전송을 해주고, 이 또한 혼잡 상태로 간주할 수 있으므로 Window의 크기를 줄입니다.

- **Fast Recovery** : 혼잡 상태가 되면 Window의 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법입니다. 해당 정책을 적용하면 혼잡 상태를 겪은 후부터 AIMD 방식으로 작동됩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## TCP/IP(Transmission Control Protocol / Internet Protocol) 모델이 무엇입니까?

OST 모델을 4계층으로 단순화 시켜서 사용하는 모델입니다. 응용 계층, 전송 계층, 인터넷 계층, 네트워크 접속 계층으로 나뉩니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## HTTP와 HTTPS는 무엇인가요?

먼저 HTTP는 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response)으로 정보를 주고 받을 수 있는 프로토콜입니다. TCP와 UDP를 사용합니다. HTTP는 평문 통신이 되기에 도청이 가능하고, 통신 상대를 확인하지 않아 위장이 가능합니다. 또한 완전성을 증명할 수 없기에 변조가 가능합니다. 이러한 문제점을 보완하기 위해 제시된 것이 HTTPS입니다. HTTP에 SSL 프로토콜을 같이 사용해 암호화와 인증, 완전성 보호를 더했습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### SSL의 동작 방식을 설명해 주세요.

SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용합니다. 즉 클라이언트와 서버가 주고받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받게 됩니다. 

> 실제 데이터 : 대칭키<br>
> 대칭키의 키 : 공개키

컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할때는 "악수 -> 전송 -> 세션종료" 3가지 단계가 있습니다.

![SSL 동작 방식](./img/SSL%20동작%20방식.png)

1. 클라이언트가 서버에 접속합니다. 이 단계를 Client Hello라고 합니다. 이 단계에서 주고 받는 정보는 아래와 같습니다.

    > - **클라이언트 측에서 생성한 랜덤 데이터**
    > - **클라이언트가 지원하는 암호화 방식들** : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 합니다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송하게 됩니다.
    > - **세션 아이디** : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이때 사용할 연결에 대한 식별자를 서버 측으로 전송합니다.

2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 됩니다. 이 단계에서 주고 받는 정보는 아래와 같습니다.

    > - **서버 측에서 생성한 랜덤 데이터**
    > - **서버가 선택한 클라이언트의 암호화 방식** : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달합니다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 됩니다.
    > - **인증서**

3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인(브라우저는 내부적으로 CA의 리스트를 미리 파악하고 있습니다)합니다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력하게 됩니다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화합니다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것입니다. 이러한 절차로 인증서를 전송한 서버를 신뢰할 수 있게 됩니다.<br><br>
클라이언트는 2번 단계를 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 **pre master secret**이라는 키를 생성하게 됩니다. 이 키는 향후 데이터를 주고 받을 때 대칭키 기법으로 암/복화화하기 위해서 사용됩니다. 즉, **pre master secret** 값은 제 3자에게 절대로 노출 되어서는 안됩니다.<br><br>
클라이언트는 공개키 방식을 이용해 **pre master secret**를 암호화 합니다. 서버에게 받은 인증서에 첨부된 서버의 공개키로 **pre master secret** 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있습니다. 이 서버의 공개키를 이용해서 **pre master secret** 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있습니다.

4. 서버는 클라이언트가 전송한 **pre master secret** 값을 자신의 비공개키로 복호화합니다. 이로서 서버와 클라이언트가 모두 **pre master secret** 값을 공유하게 되었습니다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 **pre master secret** 값을 **master secret** 값으로 만듭니다. **master secert** 은 **session key**를 생성하는데 이 값을 이용해서 서버와 클라이언트는 향후 데이터를 대칭키 방식으로 암호화한 후에 주고 받게 됩니다.

5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알립니다.

이후 세션키를 통해 데이터를 주고 받고, 전송이 종료되면 세션키를 폐기하고 통신을 종료합니다.

##### 참고자료

- https://12bme.tistory.com/80

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 단방향 암호화와 양방향 암호화는 무엇인가요?

단방향 암호화는 암호화는 가능하지만 복호화가 불가능한 방식입니다. 흔히 사용된는 해쉬 함수가 대표적인 단방향 암호화 기법입니다. 복호화의 가정이 불필요할 때 사용됩니다. 반면, 양방향 암호화는 암호화와 복호화가 모두 가능한 방식입니다. 크게 대칭키 기법과 공개키 기법이 있습니다. SSL 프로토콜은 양방향 암호화를 이용합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 대칭키와 공개키는 무엇입니까?

대칭키는 암호화 키와 복호화 키가 같은 알고리즘입니다. SHA나 MD5등이 있으며, 암호화 키는 공개되지 않고 이를 알고 있는 자만 문서를 해독할 수 있습니다. 속도는 빠르지만 키 교환의 문제나 향후 키의 수가 증가할 경우 키를 관리하기 어려운 문제를 가지고 있습니다. 반면 공개키는 암호화 키와 복호화 키가 상이합니다. 암호화 키를 공개하며 개인이 가지고 있는 복호화 키로 해독이 가능합니다. 대표적으론 RSA알고리즘이 있으며, 대칭키에 비해 속도가 느리지만 비밀키를 복호화하는 것이 불가능하기에 보안유지가 용이합니다. SSL에 사용되는 방식 또한 공개키 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 암호화 키를 비공개하고 복호화 키를 공개하는 경우에 대해 설명해 주세요.

대표적으로 데이터를 제공한 사람의 신원을 보장하는 전자서명에 사용됩니다. 일례로 SSL 작동 방식 가운데 클라이언트 측에서 CA를 판별할 때, 해당 데이터를 암호화 할 수 있는 대상은 개인키를 소유한 CA밖에 없으므로 해당 암호화 된 데이터를 수신한 서버를 신뢰할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP의 GET과 POST에 대해 설명해 주세요.

둘 모두 서버에 무엇인가를 요청할 때 사용하는 방식입니다. GET은 요청한 데이터가 HTTP Request Message의 헤더 부분에 url이 담겨서 전송됩니다.따라서 데이터가 url상에 붙어서 request가 보내집니다. 전송할 수 있는 크기가 제한적이고, 보안이 필요한 데이터도 그대로 url에 노출됩니다. POST는 요청한 데이터가 HTTP Request Message의 바디 부분에 담겨서 전송됩니다. GET 방식에 비해 보낼 수 있는 데이터 크기가 크고 보안면에서 낫습니다. 용도는 GET은 데이터를 가져오는 것에 있고, POST는 값이나 상태를 바꾸는 것 즉, 수행하는 것에 있습니다.

##### 참고자료

- http://tcpschool.com/jquery/jq_ajax_httpRequest

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

#### 조회에 POST보다 GET이 사용되는 이유는 무엇인가요?

GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답을 주는 것이 가능하고 캐싱을 이용할 수 있어 속도 면에서 빠릅니다. 또한 웹에서 모든 리소스는 링크할 수 있는 url을 가지고 있어야 합니다. 그런 측면에서 POST 방식을 사용할 경우에 값이 Body에 있기 때문에 url만 전달할 수 없습니다.

> **웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다?**<br>
> 어떤 페이지를 조회할 때, 해당 페이지로 바로 이동하기 위해서는 해당 링크의 정보(url)이 필요하다는 의미입니다. 또한, 이를 다른 사람에게 전달하고 싶을 때도 url이 필요합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP Method에서 POST과 PATCH의 차이점을 설명해 주세요.

post -> 모두 교체<br>
patch -> 일정부분<br>

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 쿠키와 세션이 무엇이며, 필요한 이유가 무엇인가요?

먼저 2개 모두 HTTP 프로토콜이 가지는 비연결 지향, 상태정보 유지 안 함의 2가지 특징 때문에 제안된 개념입니다. HTTP 프로토콜에서 상태를 유지하기 위한 기술입니다. 먼저 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일입니다. 클라이언트의 상태 정보를 브라우저에 저장하여 참조합니다. 사용자 정보나 쇼핑몰 장바구니 등에 사용됩니다. 세션은 일정 시간 동안 같은 브라우저로부터 오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술입니다. 용도는 로그인 등에 사용됩니다. 세션 또한 쿠키를 수단으로 상태 정보를 유지하지만 여러 가지 차이점이 존재합니다. 먼저 쿠키는 클라이언트에, 세션은 서버에 정보를 저장하고, 보안상 세션이 더 유리한 점이 있습니다. 하지만 쿠키는 브라우저를 종료해도 남아있지만 세션은 브라우저 종료 시 삭제됩니다. 속도면 또한 쿠키는 빠르지만 세션의 경우 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요하고 따라서 쿠키보다는 느린 점을 보입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 소켓 프로그래밍이란 무엇인가요?

먼저 소켓은 프로그램이 네트워크에서 데이터를 송수신할 수 있도록 네트워크 환경에 만들어진 연결부입니다. 이를 이용한 통신 프로그래밍을 소켓 프로그래밍이라고 합니다.

##### 참고자료

- https://recipes4dev.tistory.com/153
- https://velog.io/@devsh/네트워크-기초-개념-정리하기-소켓과-소켓-프로그래밍-개념

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 클라이언트 소켓과 서버 소켓이 무엇인가요?

두 개의 시스템 혹은 프로세스가 소켓을 통해 네트워크 연결을 만들기 위해서는, 최초에 클라이언트 측에서 서버 측으로 연결을 요청해야 합니다. IP 주소와 포트번호로 서버를 식별하였을 때 해당 요청을 처리할 수 있을 때 요청을 받아들입니다. 이 때, 연결 요청을 보내는 소켓을 클라이언트 소켓, 요청을 받아들이는 소켓을 서버 소켓이라고 합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 소켓 API의 실행 흐름에 대해서 설명해 주세요.

클라이언트 소켓은 처음 소켓을 생성하고 연결을 요청합니다. 연결이 받아들여지면 데이터를 송수신하고 모든 처리가 완료되면 소켓을 닫습니다. 서버 소켓의 경우 소켓을 생성하고 서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 결합시킵니다. 이후 연결 요청이 수신되는지 주시하다가 요청이 수신되면 이를 받아들입니다. 이후 데이터를 송수신하고 모든 처리가 완료되면 소켓을 닫습니다.

![소켓 API 실행 흐름도](./img/소켓%20API%20실행%20흐름도.png)

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### HTTP 통신과 소켓 통신의 장단점을 설명해 주세요.

HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단반향 통신입니다. 서버로부터 응답을 받은 후에는 연결이 바로 종료됩니다. 반면 소켓 통신은 특정 포트로 연결을 성립하고 있기 때문에 실시간으로 양방향 통신을 할 수 있습니다. 따라서 필요에 따라 서버 또한 클라이언트로 요청을 보낼 수 있습니다. 이러한 특성 때문에 HTTP 통신은 불필요한 자원의 점유를 없애 비용 및 유지보수 등이 좋습니다. 다만, 실시간 통신에는 많은 부하가 걸립니다. 반면, 소켓 통신은 접속을 계속 유지하기에 실시간으로 데이터를 주고 받는 게임이나 채팅 등의 서비스를 제공하기 용이하지만 서버의 자원에 따라 연결할 수 있는 클라이언트의 수가 제한됩니다.

##### 참고자료

- https://mangkyu.tistory.com/48
- https://wiper2019.tistory.com/185

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 웹 브라우저에 URL을 입력하면 일어나는 시나리오에 대해 설명해 주세요.

![웹의 동작 원리](./img/웹의%20동작%20원리.png)

①, ② : 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력함.<br>
③ : 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색함.<br>
④ : DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함.<br>
⑤, ⑥ : 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성함.<br>
이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨.<br>
⑦ : 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환됨.<br>
⑧ : 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색함.<br>
⑨, ⑩ : 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성함.<br>
이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨.<br>
⑪ : 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨.<br>
⑫ : 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨.<br>

간략히 요약하면 사용자가 URL입력 시 브라우저는 이를 DNS서버에 요청하여 해당하는 IP주소를 전달받고, 이를 토대로 서버와 연결을 구축 후 서버에서 보내주는 데이터를 브라우저 상에 띄우게 됩니다. 최근에는 클라이언트와 서버 사이에 프록시 서버가 추가되어 운용됩니다.

##### 참고자료

- http://tcpschool.com/webbasic/works
- https://owlgwang.tistory.com/1

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### DNS 동작 방식을 설명해 주세요.

![DNS 동작 방식](./img/DNS%20동작%20방식.png)

1. 브라우저에 www.example.com 을 입력
- **캐시 DNS의 www.example.com 캐시가 있을 때**<br>
    2. 클라이언트가 www.example.com 으로 요청 시, 클라이언트의 Resolver에 등록된 캐시 네임서버(DNS resolver)로 질의.<br>
    7. 캐시 DNS(Resolver 네임서버)가 www.example.com 에 대한 캐시가 있을 경우, 클라이언트에게 응답하여 종료<br>
- **캐시 DNS의 www.example.com 캐시가 없을 때**<br>
    2. 클라이언트가 www.example.com 으로 요청 시, 클라이언트의 Resolver에 등록된 캐시 네임서버(DNS resolver)로 질의.<br>
    3. 캐시 DNS(Resolver 네임서버)가 www.example.com 에 대한 캐시가 없을 경우, root 네임서버로 .com 네임서버 질의하여 .com(TLD) 네임서버 주소를 받음.<br>
    4. .com 네임서버에게 example.com 네임서버 주소 질의하여 example.com 네임서버 주소 받음<br>
    5. example.com 네임서버에게 www.example.com 에 대한 주소를 질의<br>
    6. www.example.com 네임서버가 자신의 www에 대한 A Record를 확인 후, IP 주소를 응답.<br>
    7. 캐시 DNS서버(Resolver)는 응답 받은 IP주소를 Client에게 전송.<br>
8. Client는 응답받은 IP주소를 이용하여 www.example.com 서버로 요청<br>
9. 8번 과정에 대한 프로토콜별 응답.<br>

##### 참고자료

- https://devopsnet.tistory.com/40

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 프록시 서버란 무엇인가요?

프록시 서버란 클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 중간에서 연결을 대리해주는 서버입니다. 사용되는 이유에는 크게 캐시 데이터 사용, 보안성, 접속 우회 등 3가지가 있습니다. 먼저, 프록시 서버에 요청된 내용 중 일부를 웹 캐시에 저장해 준다면, 클라이언트가 동일한 요청을 보낼 시 프록시에서 바로 해당 데이터를 줄 수 있습니다. 이는 서버 운용 속도도 높일 뿐더러, 서버에 들어가는 트래픽을 줄여서 서버 부하도 줄여줍니다. 프록시 사용 시 보안성을 위해 프록시 자체를 방화벽으로 사용할 수 도 있고, 클라이언트의 IP를 숨길 수도 있습니다. 마찬가지로 접속 우회의 경우, IP를 위장할 수 있기에 서버에서 다른 클라이언트로 접속한 것처럼 속일 수 있기에 접속 제한을 우회할 수 있습니다.

##### 참고자료

- https://liveyourit.tistory.com/251

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 웹 서버와 웹 애플리케이션 서버란 무엇인가요?

웹 서버는 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 정적 컨텐츠를 제공하는 프로그램입니다. 반면, 웹 애플리케이션 서버는 HHTP를 통해 전달된 클라이언트의 요청에 따라 동적인 컨텐츠롤 제공하는 프로그램입니다.<br>
웹 애플리케이션 서버는 웹 서버에서 동적인 요청을 전달받고, 이와 관련된 로직을 처리하여 웹 서버로 보내며, 이를 웹 서버에서 클라이언트에 전달합니다.

##### 참고자료

- https://binux.tistory.com/32
- https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 네트워크 바이트 오더가 무엇입니까?

바이트 오더란 시스템 내부적으로 데이터를 저장하는 순서입니다. 그 중에서 네트워크 상에 데이터를 전송할 때 택하는 바이트 오더를 네트워크 바이트 오더라고 합니다. 바이트 오더는 크게 빅 엔디안과 리틀 엔디안이 있는데, 네트워크 바이트 오더에선 빅 엔디안을 흔히 사용합니다. 이에 반해 흔히 사용하는 CPU, 인텔 CPU에선 리틀 엔디안을 사용하기에 네트워크 통신 시 리틀 엔디안을 빅 엔디안으로, 혹은 빅 엔디안을 리틀 엔디안으로 변환해주는 작업이 필수적으로 이뤄져야 합니다. 소켓 통신 시 자주 사용되는 write나 read 함수는 이미 내부적으로 엔디안 처리가 구현되어 있습니다.

##### 참고자료

- https://jhnyang.tistory.com/226

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 빅 엔디안과 리틀 엔디안이 무엇이고, 각각의 장단점은 무엇입니까?

![리틀 엔디안과 빅 엔디안](./img/리틀%20엔디안과%20빅%20엔디안.png)

최상위 바이트가 앞에 오는 것이 빅 엔디안, 최하위 바이트가 앞에 오는 경우 리틀 엔디안이라고 합니다. 리틀 엔디안의 경우, 수학적 연산이 쉽고, 단위가 커질 경우 해당 연산처리가 빠릅니다. 반면, 빅 엔디안의 경우 비교 연산이 쉽고, 디버깅 과정에서 메모리 값을 보는 것이 편합니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## 로드 밸런싱이 무엇인가요?

늘어나는 트래픽을 감당하기 위해 제안된 방법으로 서버 하드웨어의 성능을 올리는 스케일 업과 여러 대의 서버가 나눠서 일하는 스케일 아웃이 있습니다. 하드웨어 향상은 비용 면에서도 비싸고, 서버가 여러 대면 무중단 서비스를 제공하는 환경 구성이 용이하기에 스케일 아웃이 자주 사용됩니다. 여기서 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 로드 밸런싱입니다. 로드 밸런서를 클라이언트와 서버 사이에 두고 부하(Load)가 일어나지 않도록 여러 서버에 분산시켜주는 방식입니다.

##### 참고자료

- https://nesoy.github.io/articles/2018-06/Load-Balancer

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### 로드 밸런서가 서버를 선택하는 방식을 설명해 주세요.

흔히 CPU스케줄링의 라운드 로빈 방식을 활용하거나 최소 연결 방식, IP 해시 방식이 있습니다. 라운드 로빈 방식은 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식입니다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합합니다. 서버가 스펙의 차이를 가지고 있다면 이를 개선한 가중 라운드 로빈 방식이 있습니다. IP 해시 방식은 IP주소를 특정 서버로 매핑하여 요청을 처리하는 방식입니다. 사용자가 항상 동일한 서버로 연결되는 것을 보장합니다. 최소 연결 방식은 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 우선적으로 트래픽을 배분하는 방식입니다. 세션이 자주 길어지거나, 서버에 분배된 트래픽이 일정하지 않은 경우 적합한 방식입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### L4 로드 밸런서와 L7 로드 밸런서에 대해 설명해 주세요.

가장 많이 활용되는 로드 밸런서입니다. OSI 7계층에 따라서 나뉘어진 장비입니다. L4 로드 밸런서는 TCP/UDP의 포트 정보를 바탕으로 서버에 분배하고 L7 로드 밸런서는 TCP/UDP 정보 뿐 아니라 HTTP의 URI, FTP의 파일 명 등의 정보를 바탕으로 로드를 분산합니다. L4 로드 밸런서는 속도가 빠르고 복호화 필요가 없기에 안전하고 값이 저렴합니다. 하지만 섬세한 라우팅이 불가능하고 사용자 IP가 수시로 바뀌는 경우에는 연속적인 서비스를 제공하기 어렵습니다. 반면 L7 로드 밸런서는 섬세한 라우팅이 가능하고 비정상적인 트래픽을 사전에 필터링 할 수 있어 서비스 안정성이 높지만, 복호화에 높은 비용을 지불해야하고 클라이언트가 로드 밸런서와 인증서를 공유해야하기 때문에 공격자가 로드 밸런서를 통해서 클라이언트 데이터에 접근할 수 있는 보안상 위험성이 존재합니다.

|**L4 로드 밸런서**|**L7 로드 밸런서**|
|:---:|:--:|
|![L4 로드 밸런서](./img/L4%20로드%20밸런서.png)|![L7 로드 밸런서](./img/L7%20로드%20밸런서.png)|

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## REST(REpresentational State Transfer)란 무엇인가요?

네트워크 상에서 Client와 Server사이의 통신 방식 중 하나입니다. 정확히는 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다. REST에는 6가지 규칙이 있으며 Uniform Interface(유니폼 인터페이스), Stateless(무상태성), Cacheable(캐싱 가능), Self-descriptiveness(자체 표현 구조), Client-Server 구조, Layered System(계층형 구조)이 그것입니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### REST의 특징을 설명해 주세요.

REST의 특징은 다음과 같습니다.

    1. Uniform Interface : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.
    1. Stateless : API 서버는 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.
    1. Cacheable : HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.
    1. Self-descriptiveness : REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.
    1. Client-Server Structure : REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.
    1. Layered System : REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.

##### 참고자료

- https://meetup.toast.com/posts/92

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

### RESTful API란 무엇인가요?

REST의 기본원칙을 성실히 지켜 API를 디자인 하는 것입니다. REST의 가장 중심된 규칙은 URI는 정보의 자원을 표현해야 한다는 것과 자원에 대한 행위는 HTTP Method로 표현해야 한다는 점입니다. 이 원칙 아래 간단히 리소스와 행위를 명시적이고 직관적으로 분리해야 하며, Message는 헤더와 바디를 명확하게 분리해서 사용해야 합니다. API 버전을 관리하고 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 하는 것 등이 RESTful하게 API를 디자인하는 것이라고 할 수 있습니다.

**[뒤로](https://github.com/tini-min/Tech-Interview) / [위로](#network)**

## ETC

<details>
 <summary><strong>한정적인 시간 가운데 선택적으로 공부하지 않은 내용입니다.</strong></summary>
 <div markdown = "1">

>시간적 여유가 있을 때 보충예정

- [네트워크 계층 - IP 관련](https://velog.io/@gndan4/네트워크-네트워크-계층)
- 3-way Handshake 보충
- HTTP Method에서 PUT과 PATCH의 차이점(예시)
- REST의 자원의 표현 (Json, XML 차이점)
- [Servlet이란](https://gmlwjd9405.github.io/2018/10/28/servlet.html)
- [Servlet과 JSP](https://gmlwjd9405.github.io/2018/11/04/servlet-vs-jsp.html)
- [MVC 아키텍쳐](https://asfirstalways.tistory.com/180?category=670025)
- [CONNECTION TIMEOUT과 READ TIMEOUT](https://inyl.github.io/programming/2017/12/02/timeout.html)

</div>
</details>