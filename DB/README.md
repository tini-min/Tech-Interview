# DB
## 1. 데이터베이스의 정의는 무엇인가요?

데이터 베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임입니다. 이를 위해 4가지의 조건을 만족시켜야 하는데 이를 각각 통합된 데이터, 저장된 데이터, 운영 데이터, 공동 데이터라고 합니다. DB는 자료의 중복을 배제한 데이터의 모임이여야 하며, 컴퓨터가 접근할 수 있는 저장매체에 저장된 자료여야 하며, 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안될 자료이며, 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료여야 합니다.

### 1-1. 데이터베이스의 특징은 무엇인가요?

실시간 접근성, 계속적인 진화, 동시 공유, 내용에 의한 참조, 데이터의 독립성 등이 있습니다.

## 2. 인데스는 무엇입니까?

데이터베이스 테이블의 모든 데이터를 검색해서 원하는 데이터를 가져오기엔 시간이 오래 걸려서 사용하는 속성입니다. 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두면 탐색속도가 빨라집니다. 다만 새로운 값의 추가나 수정, 삭제의 경우 실행속도가 느려집니다.

### 2-1. DBMS의 인덱스는 어떤 알고리즘으로 관리되나요?

일반적으로 사용되는 인덱스 알고리즘은 B+- Tree 알고리즘입니다. B+- Tree 알고리즘은 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘입니다. 메모리 기반의 데이터베이스에서는 Hash 인덱스 알고리즘 또한 많이 사용됩니다. 칼럼의 값으로 해시 값을 인덱싱하는데, 값을 변경해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색하는 등의 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없습니다.

### 2-2. 인덱스 생성에 해시 알고리즘 보다 B-알고리즘이 사용되는 이유가 무엇인가요?

데이터에 접하는 시간복잡도가 O(1)인 해시 테이블이 더 유리해 보이지만, SELECT 질의의 조건에는 부등호 연산도 포함되고 해시테이블은 동등 연산에 특화되어있어 적합하지 않기 때문입니다.
(참조 https://zorba91.tistory.com/293)

### 2-3. DML이 자주 일어나는 경우 인덱스를 사용하면 어떻게 되나요?

기존 블록에 여유가 없을 때 새로운 데이터를 입력받게 되면 새로운 블록을 할당받고 키를 옮기는 작업(Index Split)을 수행합니다. 많은 Redo가 기록되고, 키를 보존하기위해 작업동안 DML이 블로킹됩니다. 삭제의 경우 데이터가 지워지지 않고 사용 안 됨 표시만 되기에 실질 데이터 수와 인덱스의 데이터 수가 차이가 생기고 업데이트는 위의 2가지 문제가 동시에 일어납니다.

### 2-4. 클러스터드 인덱스와 넌클러스터드 인덱스가 무엇인가요?

클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용입니다. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현합니다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 합니다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 합니다. 반대로 넌클러스터드 인덱스는 기준 선정이 비교적 자유롭고 별도의 인덱스 페이지를 생성하기에 물리적인 데이터들의 순서는 상관이 없습니다. 다만 용량을 더 차지하고 클러스터드 인덱스에 비해 DML은 빠르지만 검색 속도는 조금 더 느립니다.

### 2-5. Composite Index란 무엇인가요?

결합 인덱스는 2개 이상의 컬럼을 합쳐서 인덱스입니다. WHERE절의 조건이 2개 이상 AND로 연결되어 사용되는 경우 주로 사용됩니다. 다만 2번째 조건으로 검색하거나 OR로 연결되어 있는 조건의 경우에선 큰 의미를 가지지 못합니다.

## 3. 키의 종류를 설명해 주세요.

키는 검색 혹은 정렬 시 Tuple을 구분할 수 있는 기준이 되는 속성입니다. 후보키, 기본키, 대체키, 슈퍼키 등이 있으며, 먼저 후보키는 유일성과 최소성을 가진 속성들의 부분집합입니다. 그 중 기본키는 후보키 중 선택한 메인키로써 Null값이나 중복값이 없어야 합니다. 대체키는 후보키 중 기본키를 제외한 나머지 키로써 보조키라고도 합니다. 슈퍼키는 유일성은 만족하지만 최소성을 만족하지 못하는 키입니다.

## 4. 정규화란 무엇인가요?

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업입니다. 나쁜 릴레이션의 속성들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업입니다. 여기서 나쁜 릴레이션은 엔티티를 구성하고 있는 속성 간에 어떠한 함수적 종속성을 만족하지 못하는 정규형을 말합니다.

### 4-1. 정규화의 종류를 설명해 주세요.

크게 제 1, 2, 3 정규형, BCNF가 있습니다. 제 1 정규형은 각 로우마다 컬럼의 값이 1개씩만 있어야 합니다. 제 2 정규형은 모든 컬럼이 완전 함수적 종속을 만족해야 합니다. 제 3 정규형은 기본키 이외의 다른 컬럼이 그 외의 다른 컬럼을 결정할 수 없는 것(이행적 함수적 종속 제거)입니다. 마지막으로 BCNF는 모든 결정자가 후보키 집합에 속하면 됩니다.

### 4-2. 갱신 이상에 대해서 설명해 주세요.

갱신 이상에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 삽입 이상의 경우 원하지 않는 자료가 삽입이 된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않는 경우이며, 삭제 이상에는 하나의 자료만을 삭제해야 하는데, 그 자료가 포함된 튜플 전체가 삭제되는 경우이며, 마지막으로 갱신 이상은 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 경우를 말합니다.

### 4-3. 정규화의 장단점과 단점에 대한 대응책은 무엇인가요?

장점으로는 갱신 이상의 제거와 사용자에게 의미있는 데이터 모델을 제공할 수 있다는 점입니다. 구조 확장 시에도 재 디자인이 최소화 됩니다. 하지만 릴레이션의 분해로 인해 릴레이션 간의 조인 연산이 많아집니다. 따라서 데이터의 중복 속성을 제거하기에 한 테이블의 용량이 작아지지만 되려 데이터를 처리할 때 속도가 빨라질 수 도, 느려질 수 도 있습니다. 조회를 하는 쿼리문에서 조인이 많이 발생하는 경우에는 이를 대비해 반정규화를 적용해야 합니다.

## 5. 트랜잭션이 무엇인가요?

데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위 입니다. (ex. 송금) 원자성, 일관성, 독립성, 지속성을 갖추어야 하며, 하나의 트랜잭션은 커밋되거나 리콜됩니다.

### 5-1. 트랜잭션 격리 수준이 뭔가요?

동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 척도입니다. 고립 수준이 높을 수록 성능이 떨어질 수 있습니다. 격리수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 순으로 상승합니다. 일반적으론 READ COMMITTED나 REPEATABLE READ가 사용됩니다.

### 5-2. 트랜잭션 격리성 관련 문제점들은 무엇인가요?

일반적으로 Dirty Read, Non-Repeatable Read, Phantom Read가 있습니다. Dirty Read 데이터 변경 후 커밋이 이뤄지기 전 조회문에서 변경 후 데이터가 조회되고, 어떠한 이유로 리콜이 되었을 때 데이터의 일관성이 깨지는 현상입니다. Non-Repeatable Read는 같은 쿼리를 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 혹은 삭제함으로써 두 쿼리의 결과가 상이한 현상이고, Phantom Read는 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상입니다.

## 6. SQL injection에 대해 설명해 주세요.

해커에 의해 조작된 SQL 쿼리문이 데이터 베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법입니다. 크게 인증 우회와 데이터 노출이 있습니다. 인증 우회는 비밀번호 뒤에 쿼리문도 같이 작성하여 보내서 해당 데이터베이스에 영향을 줄 수도 있는 공격 방식이며, 데이터 노출은 시스템에서 발생하는 에러 메시지를 이용해 공격하는 방식입니다.

### 6-1. SQL injection을 방어할 수 있는 방법들을 설명해 주세요.

먼저 input값을 받을 때 특수 문자 여부를 미리 검사하여 요청을 막을 수도 있고, 서버 오류 발생 시 해당하는 에러 메시지를 감추는 방법이 있습니다. 이 경우 View를 활용하여 일반 사용자는 View로만 접근하여 에러를 볼 수 없습니다. 또한 PreparedStatement를 사용하면 특수문자를 자동으로 escaping해주기 때문에 필터링 과정을 통해 공격을 방어할 수 있습니다.

### 6-2. Statement vs PreparedStatement

https://java.ihoney.pe.kr/76 (보충 필요)

우선 속도 면에서 PreparedStatement가 빠르다고 알려져 있다. 이유는 쿼리를 수행하기 전에 이미 쿼리가 컴파일 되어 있으며, 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이루어지기 때문이다.

Statement에는 보통 변수를 설정하고 바인딩하는 static sql이 사용되고 Prepared Statement에서는 쿼리 자체에 조건이 들어가는 dynamic sql이 사용된다. PreparedStatement가 파싱 타임을 줄여주는 것은 분명하지만 dynamic sql을 사용하는데 따르는 퍼포먼스 저하를 고려하지 않을 수 없다.

하지만 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에서 레코드(row)를 가져오는 과정이고 SQL 문을 파싱하는 시간은 이 시간의 10 분의 1 에 불과하다. 그렇기 때문에 SQL Injection 등의 문제를 보완해주는 PreparedStatement를 사용하는 것이 옳다.

## 7. NoSQL이 무엇인가요?

관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소입니다.  저장 방식에 따라서 Key-Value Model, Document Model, Column Model, Graph Model로 분류할 수 있습니다.