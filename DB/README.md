# DB
<details>
 <summary><strong style = "font-size : 120%;">0. 용어 정리 (기초용어)</strong></summary>
 <div markdown = "1">

- 릴레이션 : 유일한 값을 가지고, 중복되지 않은 튜플을 가진 테이블
- 컬럼 = 필드 = 속성
- 로우 = 레코드 = 튜플

</div>
</details>

## 1. 데이터베이스의 정의는 무엇인가요?

데이터 베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임입니다. 이를 위해 4가지의 조건을 만족시켜야 하는데 이를 각각 통합된 데이터, 저장된 데이터, 운영 데이터, 공동 데이터라고 합니다. DB는 자료의 중복을 배제한 데이터의 모임이여야 하며, 컴퓨터가 접근할 수 있는 저장매체에 저장된 자료여야 하며, 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안될 자료이며, 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료여야 합니다.

### 1-1. 데이터베이스의 특징은 무엇인가요?

실시간 접근성, 계속적인 진화, 동시 공유, 내용에 의한 참조 등이 있습니다. 실시간 접근성(Real-Time Accessibility)은 수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다라는 것이며, 계속적인 변화(Continuous Evolution)는 데이터베이스의 상태는 동적이다는 개념입니다.  동시공용(Concurrent Sharing)은 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다는 것이며, 내용에 의한 참조(Content Reference)는 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다는 내용입니다.

## 2. 인데스는 무엇입니까?

데이터베이스 테이블의 모든 데이터를 검색해서 원하는 데이터를 가져오기엔 시간이 오래 걸려서 사용하는 속성입니다. 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두면 탐색속도가 빨라집니다. 다만 새로운 값의 추가나 수정, 삭제의 경우 실행속도가 느려집니다.

### 2-1. DBMS의 인덱스는 어떤 알고리즘으로 관리되나요?

일반적으로 사용되는 인덱스 알고리즘은 B+- Tree 알고리즘입니다. B+- Tree 알고리즘은 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘입니다. 메모리 기반의 데이터베이스에서는 Hash 인덱스 알고리즘 또한 많이 사용됩니다. 칼럼의 값으로 해시 값을 인덱싱하는데, 값을 변경해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색하는 등의 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없습니다.

#### 2-1-1. 해시 인덱스가 사용되는 예시를 들어주세요.

메모리 기반의 데이터베이스 즉, 인-메모리 데이터베이스에서 주로 사용이 됩니다. 인-메모리 데이터베이스는 NoSQL에 속하는 데이터베이스이며, Key-Value방식을 사용하고 있습니다.

### 2-2. 인덱스 생성에 해시 알고리즘 보다 B-알고리즘이 사용되는 이유가 무엇인가요?

데이터에 접하는 시간복잡도가 O(1)인 해시 테이블이 더 유리해 보이지만, SELECT 질의의 조건에는 부등호 연산도 포함되고 해시테이블은 동등 연산에 특화되어있어 적합하지 않기 때문입니다.
(참조 https://zorba91.tistory.com/293)

### 2-3. DML이 자주 일어나는 경우 인덱스를 사용하면 어떻게 되나요?

기존 블록에 여유가 없을 때 새로운 데이터를 입력받게 되면 새로운 블록을 할당받고 키를 옮기는 작업(Index Split)을 수행합니다. 많은 Redo가 기록되고, 키를 보존하기위해 작업동안 DML이 블로킹됩니다. 삭제의 경우 데이터가 지워지지 않고 사용 안 됨 표시만 되기에 실질 데이터 수와 인덱스의 데이터 수가 차이가 생기고 업데이트는 위의 2가지 문제가 동시에 일어납니다.

##### 참고자료

- https://multifrontgarden.tistory.com/11

### 2-4. 클러스터드 인덱스와 넌클러스터드 인덱스가 무엇인가요?

클러스터드 인덱스는 해당 키를 기준으로 물리적으로 테이블을 정렬하는 인덱스 입니다. 일반적으로 프라이머리 키를 해당 키로 설정합니다. 또한, 물리적으로 테이블을 정렬해야 하기에 테이블 당 한개만 설정할 수 있습니다. 특징으로는 값이 비슷한 키들은 물리적으로 인접한 곳에 저장(밀집되어 있음)된다는 것입니다. 이와는 다르게 넌클러스터드 인덱스는 별도의 인덱스 페이지를 생성하여 해당 페이지에 논리적으로 키가 정렬되어 있는 인덱스입니다. 따라서 값이 비슷한 키들이 물리적으로 인접하지 않을 수 있습니다. 물리적 제약이 없기에 다수의 키를 선정함에 있어서도 비교적 자유롭습니다. 클러스터드 인덱스는 별도의 인덱스 페이지를 생성하지 않기에 비교적 용량이 적고, 탐색속도가 빠릅니다. 하지만 DML명령 시 물리적으로 데이터베이스를 재정렬해야하기에 수정 속도가 느립니다.

### 2-5. Composite Index란 무엇인가요?

결합 인덱스는 2개 이상의 컬럼을 합쳐서 인덱스입니다. WHERE절의 조건이 2개 이상 AND로 연결되어 사용되는 경우 주로 사용됩니다. 다만 2번째 조건으로 검색하거나 OR로 연결되어 있는 조건의 경우에선 큰 의미를 가지지 못합니다.

## 3. 키의 종류를 설명해 주세요.

키는 검색 혹은 정렬 시 Tuple을 구분할 수 있는 기준이 되는 속성으로 슈퍼키, 후보키, 기본키, 대체키, 외래키 등이 있습니다. 먼저 슈퍼키는 유일성을 만족하는 키이며, 후보키는 이런 슈퍼키 중에서 유일성을 만족시킬 수 있는 최소한의 집합입니다. 그 중 기본키는 후보키 중 선택한 메인키로써 Null값이 없고 값의 변동이 적고 단순한 키를 선택합니다. 대체키는 후보키 중 기본키를 제외한 나머지 키로써 보조키라고도 합니다. 외래키는 어떤 릴레이션에 소속된 속성 또는 속성 집합이 다른 릴레이션의 기본키가 되는 키입니다.

##### 참고자료

- https://kosaf04pyh.tistory.com/201

## 4. 정규화란 무엇인가요?

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업입니다. 나쁜 릴레이션의 속성들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업입니다. 여기서 나쁜 릴레이션은 엔티티를 구성하고 있는 속성 간에 어떠한 함수적 종속성을 만족하지 못하는 정규형을 말합니다.

### 4-1. 정규화의 종류를 설명해 주세요.

크게 제 1, 2, 3 정규형, BCNF가 있습니다. 제 1 정규형은 각 로우마다 컬럼의 값이 1개씩만 있어야 합니다. 제 2 정규형은 모든 컬럼이 완전 함수적 종속을 만족해야 합니다. 제 3 정규형은 기본키 이외의 다른 컬럼이 그 외의 다른 컬럼을 결정할 수 없는 것(이행적 함수적 종속 제거)입니다. 마지막으로 BCNF는 모든 결정자가 후보키 집합에 속하면 됩니다.

##### 참고자료

- https://yaboong.github.io/database/2018/03/09/database-normalization-1/
- https://yaboong.github.io/database/2018/03/10/database-normalization-2/

### 4-2. 이상 현상에 대해서 설명해 주세요.

이상 현상에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 삽입 이상의 경우 원하지 않는 자료가 삽입이 된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않는 경우이며, 삭제 이상에는 하나의 자료만을 삭제해야 하는데, 그 자료가 포함된 튜플 전체가 삭제되는 경우이며, 마지막으로 갱신 이상은 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 경우를 말합니다.

##### 참고자료

- https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/

### 4-3. 정규화의 장단점과 단점에 대한 대응책은 무엇인가요?

장점으로는 갱신 이상의 제거와 사용자에게 의미있는 데이터 모델을 제공할 수 있다는 점입니다. 구조 확장 시에도 재 디자인이 최소화 됩니다. 하지만 릴레이션의 분해로 인해 릴레이션 간의 조인 연산이 많아집니다. 따라서 데이터의 중복 속성을 제거하기에 한 테이블의 용량이 작아지지만 되려 데이터를 처리할 때 속도가 빨라질 수 도, 느려질 수 도 있습니다. 조회를 하는 쿼리문에서 조인이 많이 발생하는 경우에는 이를 대비해 반정규화를 적용해야 합니다.

## 5. 트랜잭션이 무엇인가요?

데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위 입니다. (ex. 송금) 원자성, 일관성, 독립성, 지속성을 갖추어야 하며, 하나의 트랜잭션은 커밋되거나 롤백됩니다.

##### 참고자료

- https://gyoogle.dev/blog/computer-science/data-base/Transaction.html

### 5-1. 트랜잭션 격리 수준이 뭔가요?

동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 척도입니다. 고립 수준이 높을 수록 성능이 떨어질 수 있습니다. 격리수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 순으로 상승합니다. 일반적으론 READ COMMITTED나 REPEATABLE READ가 사용됩니다.

### 5-2. 트랜잭션 격리성 관련 문제점들은 무엇인가요?

일반적으로 Dirty Read, Non-Repeatable Read, Phantom Read가 있습니다. Dirty Read 데이터 변경 후 커밋이 이뤄지기 전 조회문에서 변경 후 데이터가 조회되고, 어떠한 이유로 롤백이 되었을 때 데이터의 일관성이 깨지는 현상입니다. Non-Repeatable Read는 같은 쿼리를 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 혹은 삭제함으로써 두 쿼리의 결과가 상이한 현상이고, Phantom Read는 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상입니다.

## 6. SQL injection에 대해 설명해 주세요.

해커에 의해 조작된 SQL 쿼리문이 데이터 베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법입니다. 인증 우회나 데이터 조작 및 유출, 시스템 명령어 실행 등을 목적으로 진행됩니다. 일반적으로 쿼리 조건을 무력화, 고의적 에러를 통해 정보를 획득, 시스템 명령어를 실행하는 등의 방식으로 진행됩니다. 이외에도 Blind SQL injection도 있습니다.

##### 참고자료

- https://m.mkexdev.net/427

### 6-1. SQL injection을 방어할 수 있는 방법들을 설명해 주세요.

먼저 input값을 받을 때 특수 문자 여부를 미리 검사하여 요청을 막을 수도 있고, 서버 오류 발생 시 해당하는 에러 메시지를 감추는 방법이 있습니다. 이 경우 View를 활용하여 일반 사용자는 View로만 접근하여 에러를 볼 수 없습니다. 또한 PreparedStatement를 사용하면 특수문자를 자동으로 escaping해주기 때문에 필터링 과정을 통해 공격을 방어할 수 있습니다.

### 6-2. Statement vs PreparedStatement

우선 속도 면에서 PreparedStatement가 빠르다고 알려져 있다. 이유는 쿼리를 수행하기 전에 이미 쿼리가 컴파일 되어 있으며, 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이루어지기 때문이다.

Statement에는 보통 변수를 설정하고 바인딩하는 static sql이 사용되고 Prepared Statement에서는 쿼리 자체에 조건이 들어가는 dynamic sql이 사용된다. PreparedStatement가 파싱 타임을 줄여주는 것은 분명하지만 dynamic sql을 사용하는데 따르는 퍼포먼스 저하를 고려하지 않을 수 없다.

하지만 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에서 레코드(row)를 가져오는 과정이고 SQL 문을 파싱하는 시간은 이 시간의 10 분의 1 에 불과하다. 그렇기 때문에 SQL Injection 등의 문제를 보완해주는 PreparedStatement를 사용하는 것이 옳다.

##### 참고자료

- https://java.ihoney.pe.kr/76 (보충 필요)

## 7. NoSQL이 무엇인가요?

관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소입니다.  저장 방식에 따라서 Key-Value Model, Document Model, Column Model, Graph Model로 분류할 수 있습니다.

##### 참고자료

- https://gyoogle.dev/blog/computer-science/data-base/SQL & NOSQL.html

## ETC

한정적인 시간 가운데 선택적으로 공부하지 않은 내용입니다. > 시간적 여유가 있을 때 보충예정

[Connection Pool](https://delf-lee.github.io/post/connection-pool/)
[ANSI/SPARC Architecture](https://neokido.tistory.com/entry/데이터베이스-ANSISPARC-Architecture) → 데이터베이스 구조 정의
[CAP이론 1](https://ohjongsung.io/2019/05/01/cap-이론과-pacelc-이론)
[CAP이론 2](http://happinessoncode.com/2017/07/29/cap-theorem-and-pacelc-theorem/)
[CAP이론 3](https://sabarada.tistory.com/91)
[전반적인 내용](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md)